# 分治算法

## 算法思想

分治算法的基本思想是：将大问题划分为若干个独立小问题，合并小问题的解可以得到大问题的解。

分治算法的3个步骤：

1. 划分：将原始问题划分或归结为规模较小的子问题
2. 独立求解子问题：**递归**或**迭代**求解每个子问题
3. 综合得解：将子问题的解综合得到原问题的解

需要注意：

1. 子问题与原始问题性质完全一样（分治基础）
2. 子问题之间可彼此独立求解
3. 递归停止时子问题可直接求解（重要特点）

### 分治算法的例子

#### 二分查找

问题：在已排序的数组$A$中查找目标数$x$

设计思想：

* $x$与中位数比较，将原问题归结为规模减半的子问题
* 对子问题进行二分查找（注意点1）
* 当子问题规模为1时，直接比较（注意点3）

```c
// 算法 Binary Search(A, l, r, x)
// 输入：已排序数组A，下标从l到r，查找数x
// 输出：查找数下标或-1
while l <= r
  m = floor((l + r) / 2) // 中间划分
  if (A[m] == x)
    return m
  else if (A[m] > x)
    r = m - 1
  else
    l = m + 1
return -1
```

递推方程：$W(n) = W(\lfloor n / 2 \rfloor) + 1, \quad W(1) = 1$

时间复杂度：$W(n) = \lfloor logn \rfloor + 1$

#### 二分归并排序

问题：长度为$n$的数组排序

设计思想：

* 将原问题划分为规模为`n / 2`的2个子问题，继续划分，将原问题划分为规模为`n / 4`的4个子问题，继续划分直到规模为1
* 规模为1时已排好序（注意点3）
* 从规模1到规模`n / 2`，子问题排序后逐层向上归并，最终得到排序数组

```c
// 算法 MergeSort(A, l, r)，对数组A中l到r的元素进行归并排序
// 输入：数组A[l...r]
// 输出：从小到大排序后的数组A
if (l < r)
  m = floor((l + r) / 2) // 中间划分
  MergeSort(A, l, m) // 子问题1
  MergeSort(A, m + 1, r) // 子问题2
  Merge(A, l, m, r) // 综合解
```

递推方程：$W(n) = 2W(n / 2) + (n - 1), \quad W(1) = 0$

时间复杂度：$W(n) = nlogn - n + 1$

#### 汉诺塔问题

设计思想：

* 将原问题归结为规模为`n - 1`的2个子问题，继续归约直到规模为1
* 规模为1时，直接移动（注意点3）
* 从规模1到`n - 1`，陆续组合两个子问题的解，直到规模为`n`

```c
// 算法Hanoi(A, C, n), 将n个盘子从A移动到C
if n = 1
  move(A, C)
else
	Hanoi(A, B, n - 1) // 将n - 1个盘子从A移动到B
	move(A, C) // 将一个盘子从A移动到C
	Hanio(B, C, n - 1) // 将n - 1个盘子从B移动到C
```

递推方程：$T(n) = 2T(n - 1) + 1, \quad T(1) = 1$

时间复杂度：$T(n) = 2 ^ n - 1$

## 一般描述和分析方法

### 一般性描述

```c
// Divide-and-Conquer(P)
if |P| <= c
  S(P)  // 当问题P的规模足够小时，直接求解
divide P into P1,P2,P3...Pk // 将问题P划分为若干个独立的子问题（划分）
for i from 1 to k // 对每个子问题递归求解（独立求解子问题）
  yi = Divide-and-Conquer(Pi)
return Merge(y1,y2,y3...yk) // 合并子问题的解得原始问题的解（综合解）
```

### 设计要点

* 原问题可以划分为规模较小的子问题
  * 子问题与原问题具有相同的性质
  * 子问题的求解彼此独立
  * 划分时子问题的规模尽可能均衡
* 子问题规模足够小时可直接求解
* 子问题的解综合得到原问题的解

分治算法通常有**递归或迭代**两种算法实现。

### 分治的递推方程

上面提到，分治算法的大概是划分、求解子问题、综合解三步，它的递推方程为：
$$
W(n) = W(P_1)+\dots+W(P_k)+f(n), \quad W(c) = C
$$
其中$W(P_1) \dots W(P_k)$为求解各个子问题的工作量，$f(n)$为划分、综合解的工作量，$W(c)$是可直接求解子问题时的工作量。

分治算法中划分子问题有两种情况：

* **子问题的个数按常数次减少**

  汉诺塔问题的递推方程为：$W(n) = 2W(n-1)+1$

  这类算法的时间复杂度求解公式为：$f(n) = \sum ^k _{i=1} {a_if(n-i)} + g(n)$

* **子问题个数按倍数划分**

  归并排序的递推方程为：$W(n) = W(n/2)+1$

  二分查找的递推方程为：$W(n) = 2W(n/2)+n-1$

  这类算法的时间复杂度求解公式为：$f(n) = af(\frac {n} {b}) + d(n)$

### 快速排序

问题：对长度为$n$的数组$A$排序

基本思想：用首元素$x$作为划分标准，将$A$划分成两个子数组，小于等于$x$的组成$A_L$，大于$x$的组成$A_R$，递归地对$A_L$和$A_R$进行排序，直到子问题规模为1。

```c
// QuickSort(A, l, r)
if (l < r)
	p = Partition(A, l, r) // 划分为两个子数组
  swap(A[l], A[p])
  QuickSort(A, l, p - 1)
  QuickSort(A, p + 1, r)
```

  ```c
  // Partition(A, l, r)
  x = A[l] // 以首元素为分界点
  i = l
  j = r + 1
  while(true)
    repeat j-- until A[j] <= x // 找到小于分界点的元素
    repeat i++ until A[i] > x // 找到大于分界点的元素

    i < j
  		? swap(A[i], A[j]) // 交换
      : return j
  ```

举个例子：对数组`27,99,8,64,86,16,7,10,88,25,90`排序，第一次`Partition`过程如下：

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu25uodit1j60fd09gjsc02.jpg)

最坏情况下：

* 递推方程：$W(n) = W(n-1)+n-1, \quad W(1) = 0$

* 时间复杂度：$W(n) = n(n-1) / 2$

最好情况下（每次都选中数组的中位数作为分界点）：

* 递推方程：$T(n) = 2T(n / 2) + (n - 1), \quad T(1) = 0$

* 时间复杂度：$T(n) = \Theta(nlogn)$

#### 小结

快速排序算法使用分治策略，它的子问题划分通常是由首元素决定的（也可以用其他方式决定）。

快速排序在最坏情况下的时间复杂度为$O(n^2)$，平均时间复杂度$O(nlogn)$。

### 幂乘算法（计算$a^n$）

问题描述：$a$为给定实数，$n$为自然数，求$a^n$

$n$为偶数：$a^n = a ^ n = a ^ {n / 2} \times a ^ {n / 2}$

$n$为奇数：$a^n = a ^ {(n - 1) / 2} \times a ^ {(n - 1) / 2} \times a$

递推方程：$W(n) = W(n / 2) + \Theta(1)$

时间复杂度：$W(n) = \Theta(logn)$

## 算法改进

对于分治的时间$W(n) = aW(n / b) + f(n)$，可通过减小$a$或减小$f(n)$来改进。其中：

* $a$：子问题个数

* $n/b$：子问题规模

* $f(n)$：划分和综合解的工作量

我们可以通过**减少子问题个数**或通过**预处理**减少$f(n)$来改进分治算法。

### 减少子问题个数

减少子问题个数的方法：利用子问题的依赖关系，使某些子问题的解通过组合其他子问题的解而得到。

#### 整数位乘问题

问题：$X,Y$是两个$n$位的二进制数，其中$n = 2^k$，求$XY$

* 普通乘法（蛮力算法）：按位相乘，需要$O(n^2)$次位乘运算

* 简单划分（未改进的分治）：

  令$X = A2^{n/2} + B,\quad Y = C2^{n/2} + D$，那么
  $$
  XY = AC2^n + (AD + BC)2^{n/2} + BD
  $$
  比如$X = 10110110,Y=10001110$

  ![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu1ibj6hroj60cs040weh02.jpg)

  此时原问题被划分为4个子问题$AC,AD,BC,BD$。

  递推方程和时间复杂度为：$W(n) = 4W(n/2)+O(n) \to W(n) = O(n^2)$

* 改进：**利用代数变换减少子问题个数**

  因为$AD + BC = (A-B)(D-C)+AC+BD$，所以将上述等式右部代入原方程，有
  $$
  XY = AC2^n + [(A-B)(D-C)+AC+BD]2^{n/2} + BD
  $$
  此时子问题减少到三个：$AC,(A-B)(D-C),BD$。

  递推方程：$W(n) = 3W(n/2)+cn, \quad W(1) = 1$

  时间复杂度：$W(n) = O(n^{1.59})$

#### 矩阵相乘问题

* Strassen矩阵乘法：$O(n ^ {2.8075})$

* Coppersmith-Winograd算法：$O(n ^ {2.376})$

矩阵乘法的时间复杂度下界为$O(n ^ 2)$，目前最好的算法是Coppersmith-Winograd算法。

矩阵运算可应用于科学计算、图像处理、决策树等算法。

### 预处理（平面点对问题）

问题：平面点集$P$中有$n$个点，$n \ge 2$，求$P$中的两个点，其距离最小

蛮力算法：共$C^2_n$个点对，两两计算距离，时间复杂度为$O(n^2)$

#### 分治算法

分治策略：$P$划分为大小相等的$P_L$和$P_R$

1. 分别计算$P_L,P_R$中最近点对$m_L,m_R$
2. 计算$P_L$与$P_R$中各一个点的最近点对$m_{L2R}$
3. $m_L,m_R,m_{L2R}$的最小值就是解

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu28kvu4rnj609p05pt8m02.jpg)

分治的具体算法：

$MinDistance(P)$

1. 若$|P| \le 3$，直接计算其最小距离
2. 点集$P$根据横坐标排序
3. 做中垂线 $l$ 将 $P$ 划分为 $P_L$ 和 $P_R$
4. $MinDistance(P_L)$
5. $MinDistance(P_R)$
6. $\delta = min(\delta_L, \delta_R)$ ，$\delta_L, \delta_R$为子问题的距离
7. 检查距离 $l$ 不超过 $\delta$ 的两侧各1个点的距离，若小于$\delta$，则更新 $\delta$ 的值

#### 跨边界处理

在上述算法的第6步，已经得到当前最短距离$\delta$。

在跨分界线判断最小距离时，如以下示意图：

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu293gyocjj60bv06ddfs02.jpg)

因为$d \lt \delta$，右边每个小方格内最多只有一个点（如果有两个点以上，它们的距离必小于$\delta$）。因此$P_L$的每个点最多与$P_R$的6个点做距离计算，反之亦然。这需要$O(n)$时间。

#### 算法分析

改进前的平面点对问题的分治算法，

* 递推方程：$T(n) = 2T(n/2)+O(nlogn)$，$T(n) = O(1),\quad n \le 3$

* 时间复杂度：$T(n) = O(nlog^2n)$

#### 改进

改进前，每次递归都需要对$X,Y$排序，因此可以预先对整个点集的$X,Y$排序，然后在递归过程中对已排序的$X,Y$做划分，使得时间复杂度降低。

有以下四个点：

| $P$  |   $p_1$    |  $p_2$   |   $p_3$   |   $p_4$   |
| :--: | :--------: | :------: | :-------: | :-------: |
| 坐标 | $(0.5, 2)$ | $(2, 3)$ | $(-2, 4)$ | $(1, -1)$ |

对$X,Y$进行排序预处理：

| $P$  |   $p_3$   |   $p_1$    |  $p_4$   |  $p_2$   |
| :--: | :-------: | :--------: | :------: | :------: |
| 坐标 | $(-2, 4)$ | $(0.5, 2)$ | $(2, 3)$ | $(2, 4)$ |

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu2an2fgh8j607g061wec02.jpg)

改进后的时间复杂度：$O(nlogn)$

## 小结

典型的分治算法：

* 选择问题
  * 选第k小、选第k大
* 信号平滑处理
  * 快速傅立叶变换FFT算法
  * 卷积计算
  * 卷积及应用
* 计算几何
  * 计算平面点集的凸包

后面会介绍选第k大、卷积计算、快速傅立叶变换、平面点集的凸包的算法。
