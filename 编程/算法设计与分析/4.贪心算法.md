# 贪心算法

## 算法思想

贪心算法适合于**组合优化问题**，求解过程是**多步判断过程**，最终的判断序列对应于问题的最优解

* **依据某种“短视的”贪心策略判断，策略的好坏决定算法的成败**

* **贪心法必须进行正确性证明**
* 证明贪心法不正确：举反例

贪心算法有**算法简单、时间空间复杂度低**的优势。

### 活动选择问题

有$n$项活动，$s_i$和$f_j$分别为活动$i$的开始和结束时间，在时间不重叠的情况下（一个时间段内只能有一个活动），求最多活动数的集合。

举个例子，有10项活动，它们的开始和结束时间如下表：

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $s_i$ |  1   |  3   |  2   |  5   |  4   |  5   |  6   |  8   |  8   |  2   |
| $f_i$ |  4   |  5   |  6   |  7   |  9   |  9   |  10  |  11  |  12  |  13  |

* 策略1：先到先服务（开始时间早的优先）

  按开始时间从小到大排序，从前先后挑选。

  这是个<span style="color: red">错误策略</span>，反例：

  <img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/007S8ZIlgy1gi84kc0motj312i09o3zg.jpg" alt="image-20200830000059459" style="zoom: 40%;" />

* 策略2：短任务优先（占用时间短的优先）

  排序使得$f_1 - s_1 \le f_2 - s_2 \le \dots \le f_n - s_n$，从前先后挑选。

  这是个<span style="color: red">错误策略</span>，反例：

  <img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/007S8ZIlgy1gi84ludqp1j311a09kab1.jpg" alt="image-20200830000228157" style="zoom:40%;" />

* 策略3：结束时间早的优先

  排序使得$f_1 \le f_2 \le \dots \le f_n$，从前先后挑选。

  （<span style="color: green">正确策略</span>，正确性的证明见后文）



  <img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/007S8ZIlgy1gi842diwj1j317o0icad7.jpg" alt="image-20200829234315889" style="zoom:50%;" />

  算法伪代码：

  ```c
  // 算法GreedySelect
  n = S.length // 活动集S已根据结束时间排序
  A = [1] // 两两相容的最大活动集合A
  j = 1
  for i from 2 to n
    if (start_i >= finish_j) {
      A.push(i)
      j = i
    }
  return A
  ```

  时间复杂度：根据结束时间排序的时间复杂度为$O(nlogn)$，选出活动集合需要$O(n)$，最终的时间复杂度：$O(nlogn)$。

## 贪心法的证明

贪心法的证明使用的是数学归纳法。

举个数学归纳法证明的例子：证明对于任何自然数$n$，$1+2+ ... +n = n(n+1)/2$

证明：

当$n=1$，等式成立，

假设对任意自然数$n$等式成立，则

$1+2+...+(n+1)\\=(1+2+...+n)+(n+1)\\=n(n+1)/2+(n+1)\\=(n+1)(n+2)/2$

等式依然成立。可以证明原命题正确。

数学归纳法有第一数学归纳法和第二数学归纳法。上面这个例子是第一数学归纳法。

### 第一数学归纳法

第一数学归纳法适合证明涉及自然数的命题$P(n)$。

证明过程分三步：

1. 证明$P(1)$为真
2. 假设对所有$n$，$P(n)$为真
3. 在上一步的假设下，证明$P(n+1)$为真

用数学符号表示证明过程如下：

$\forall n, P(n) \to P(n+1) \\ P(1) \to P(2) \to P(3) \to \dots$

### 第二数学归纳法

和第一数学归纳法一样，第二数学归纳法也是适合证明涉及自然数的命题$P(n)$。

证明过程类似：

1. 证明$P(1)$为真
2. 假设对所有小于$n$的$k$，$P(k)$为真
3. 在上一步的假设下，证明$P(n)$为真

用数学符号表示证明过程如下：

* $\forall k(k < n \wedge P(k)) \to P(n)$

* $n=2, \ P(1) \to P(2)$
* $n=3, \ P(1) \wedge P(2) \to P(3)$
* $n=3, \ P(1) \wedge P(2) \wedge P(3) \to P(4)$
* $\dots$

第一数学归纳法和第二数学归纳法的归纳证明示意图：

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gutwtwflggj60az080glu02.jpg" style="zoom:90%;" />

### 装载问题

有$n$个集装箱，集装箱的重量为$w_i$，轮船重量限制为$C(w_i < C)$，无体积限制，求使集装箱最多的装法。

:::tip

该问题是0-1背包问题的子问题，集装箱相当于物品，重量是$w_i$，轮船相当于背包。

与0-1背包问题最大的不同在于物品价值都是1。

:::

用数学符号建模：

* 解：$<x_1,...x_n>, x_i = 0,1$，$x_i = 1$表示第$i$个集装箱装上船
* 目标函数：$max \displaystyle\sum_{i=1}^{n}x_i$（集装箱数量最多）
* 约束条件：$\displaystyle\sum_{i=1}^{n}w_ix_i \le C$（不超出重量限制）

贪心策略：轻者优先

将集装箱按重量从小到大装箱，直到装入下一个箱子会超重。

## 得不到最优解时

### 找零问题
