# 算法设计与分析

下图是本文的大纲，重点内容是分治、动态规划等算法思想。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gu064vqa44j60a208raak02.jpg)

## 算法设计（如何设计一个算法）

要想设计一个算法来解决某个问题，主要有三个步骤：

1. 问题建模

   对输入参数和问题的解给出形式化或半形式化的描述。

   建模内容包括**输入、输出、目标函数、解**。

2. 设计算法

   针对已经建模的问题设计算法，首先**根据问题的类型，选择算法思想**。

   常见的算法思想有**蛮力、分治、动态规划、贪心、回溯、分支限界**等。

   除此之外，还要**验证算法的正确性**。验证算法是否对所有实例都有最优解，如果不是，找到反例。

3. 分析算法效率

   算法效率包括**时间复杂度**和**空间复杂度**。

## 算法分析（时间复杂度）

算法的时间复杂度：针对指定**基本运算**，计算算法所做的**运算次数**。

其中基本运算包括：比较、四则运算、指针操作、交换等。比如排序问题中，基本运算就是比较两个数的大小。

常见问题的基本运算：

* 排序：元素之间的**比较**
* 检索：检索目标和被检索数组中元素的**比较**
* 图的遍历：**指针操作**
* ...

解决一个问题所需的运算次数跟问题的**输入规模**有关。

因此，**算法的时间复杂度表示为输入规模的函数**。

常见问题的输入规模：

* 排序：数组中元素的个数
* 检索：被检索数组的元素个数
* 图的遍历：图的顶点数和边数
* ...

设输入规模为$n$，则：

* 最坏情况下的时间复杂度为$W(n)$
* 平均情况下的时间复杂度为$A(n)$

### 函数渐进的界

* $f(n) = O(g(n))$: 时间复杂度的渐进上界为$g(n)$
* $f(n) = \Omega(g(n))$: 时间复杂度的渐进下界为$g(n)$
* $f(n) = o(g(n))$: $f(n)$比$g(n)$低阶
* $f(n) = \omega(g(n))$: $f(n)$比$g(n)$高阶
* $f(n) = \Theta(g(n))$: $f(n)$与$g(n)$同阶

### 函数阶的高低

* 指数级：$2^n,3^n,n! \: \dots$
* 多项式级：$n,n^2,n^3,nlogn,n^{1/2} \: \dots$
* 对数多项式级：$logn,log2n,loglogn \: \dots$

### 小结

算法的时间复杂度是由算法做了多少次基本操作决定的。常见的基本操作有：比较、加减乘除、指针操作、交换等。

算法的时间复杂度表示为输入规模的函数。比如$f(n) = n^2 + n + 1$。

假设某个算法的时间复杂度为表示为$A(n) = O(n^2)$或$W(n) = O(2^n)$，这表示该算法的平均时间复杂度的渐进上界为$n^2$，最坏情况下的时间复杂度的上界为$2^n$。平均情况下，该算法的时间复杂度是多项式级的。

## 问题的计算复杂度

**问题的计算复杂度考虑的是一类问题而不是某个具体算法。**

以排序问题为例，有以下常见的排序算法，它们的时间复杂度如表所示：

|   算法   |  最坏情况  |  平均情况  |
| :------: | :--------: | :--------: |
| 冒泡排序 |  $O(n^2)$  |  $O(n^2)$  |
| 插入排序 |  $O(n^2)$  |  $O(n^2)$  |
| 快速排序 |  $O(n^2)$  | $O(nlogn)$ |
| 归并排序 | $O(nlogn)$ | $O(nlogn)$ |
|  堆排序  | $O(nlogn)$ | $O(nlogn)$ |

这5个排序算法都是**以元素比较作为基本运算**的。

那么在排序问题的所有算法中，哪个排序算法效率最高，这就是问题的计算复杂度要研究的问题。

也就是说，排序问题的计算复杂度考虑的是排序问题本身而不是具体的某个算法（比如快速排序）。

*目前已知排序问题的时间复杂度下界为$O(nlogn)$。*

## 计算复杂性理论

常见的`NP-hard`问题：旅行问题、0-1背包问题。

计算复杂性理论的内容见《计算科学》和《P=NP问题》。

这里可以总结下算法的研究内容间的关系：

问题 --> 建模、设计算法                                ====> 算法设计技术

算法 --> 算法的评价（时间、空间复杂度） ====> 算法分析方法

算法类 --> 问题复杂度估计                            ====> 问题复杂度分析

问题类 --> 能够求解的边界                            ====> 计算复杂性理论

## 如何计算时间复杂度

算法里操作次数通常在于两种情况：循环、递归。

* 循环情况下使用序列求和的方式计算，如果不能准确得出基本操作的次数，需要对序列的和进行估计。

* 序列求和的公式有：等差数列、等比数列、调和级数。

  估计序列的和有两种方法：放大法求上界、积分求渐进界。

递归情况下，使用递推方程计算。

下面举三个例子：

* Fibonacci数
  Fibonacci数：$\{1,1,2,3,5,8,13,21 \dots \}$

  递推方程：$f(n) = f(n - 1) + f(n - 2), n \ge 2, \quad f(0) = 1, f(1) = 1$

* 汉诺塔问题

  ```c
  // 算法Hanoi(A, C, n), 将n个盘子从A移动到C
  if n = 1 then move(A, C)
  else
  	Hanoi(A, B, n - 1) // 将n - 1个盘子从A移动到B
  	move(A, C) // 将一个盘子从A移动到C
  	Hanio(B, C, n - 1) // 将n - 1个盘子从B移动到C
  ```

  递推方程：$T(n) = 2T(n - 1) + 1,\quad T(1) = 1$

  递推方程的解：$T(n) = 2^n - 1$

* 插入排序

  递推方程：$W(n) = W(n - 1) + (n - 1), \quad W(1) = 1$

### 递推方程求解

对形如以下的递推方程：
$$
T(n) = aT(n / b) + f(n)
$$

* $a$：归约后的子问题个数

* $n / b$：归约后子问题的规模

* $f(n)$：归约过程以及组合子问题的工作量

比如二分归并排序的递推方程：
$$
T(n) = 2T(n / 2) + n - 1
$$
