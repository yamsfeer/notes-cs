# 回溯算法

## n皇后问题

$n$皇后问题：在$n*n$的棋盘上放置$n$个皇后，皇后之间不可互相攻击（不在同行、同列或同斜线上），求有多少种布局。

$n$皇后问题的解可以用$n$维向量$<x_1,\dots,x_n>$来表示，每个元素表示的是棋盘的列。

经典的8皇后问题有92个解，其中一个是$<1,5,8,6,3,7,2,4>$。

以4皇后问题为例，它的解有$<2,4,1,3>$和$<3,1,4,2>$。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h236ph43s9j209103xt8m.jpg)

### 搜索空间

求解$n$皇后问题的过程可以用一个$n$叉树表示，4皇后问题的搜索空间是一个4叉树。

从根节点开始，每个节点有4个子节点，分别代表4列，虚线表示冲突（可以攻击），一旦有冲突，即可回溯。

叶子节点表示一个解，按深度优先搜索遍历树，可以得到所有解。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gulsu1z46oj609104wdfu02.jpg)

## 0-1背包问题

有$n$种物品，每种物品只有1个，第$i$种物品价值为$v_i$，重量为$w_i$，背包最大重量为$B$，

求如何选择物品，使得背包价值最大。

0-1背包问题的解可以用$n$维向量$<x_1,\dots,x_n>$表示，$x_i = 1$表示物品$i$放入背包。

举个例子，假设背包最大重量为13，物品如下表：

| 物品 |  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: | :--: |
| $v$  |  12  |  11  |  9   |  8   |
| $w$  |  8   |  6   |  4   |  3   |

此问题的最优解为$<0,1,1,1>$，最终背包价值为28，重量达到最大重量13。

0-1背包问题的求解过程可以用一个**子集树**来表示。

对于每个物品，要么放入要么不放入，因此会有$2^n$个可能，也就是$2^n$个叶子节点。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gumxu4tu6jj60qc09aq3w02.jpg)

## 旅行问题

有$n$个城市，已知任意两个城市间距离，求一条恰好经过每个城市一次的回路，且长度最小。

举个例子，假设有ABCD四个城市，它们之间的距离关系如下图，它的解为$<A,B,D,C>$，总长度为23。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gungd87tmrj606005qdfr02.jpg)

求解旅行问题的搜索空间是一个**排列树**，共有$(n-1)!$个叶子节点。

假设从A城市开始，此时有三种可能的选择，每选择一个城市，可选的城市跟着递减。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gungd51kuhj609d07l3yl02.jpg)

## 算法思想

总结下上面三个问题的特点：

* 它们的解都是一个向量
* 搜索空间都是树，可行解在叶子节点
* 有深度优先、广度优先等遍历方法

|   问题   | 解性质 |        解向量        | 搜索空间 |    搜索方式    |     约束条件     |
| :------: | :----: | :------------------: | :------: | :------------: | :--------------: |
|  n皇后   | 可行解 |       棋盘列号       | $n$叉树  | 深度、广度优先 |    彼此不攻击    |
| 0-1背包  | 最优解 |     是否放入背包     |  子集树  | 深度、广度优先 |   不超背包重量   |
| 旅行问题 | 最优解 |       城市顺序       |  排列树  | 深度、广度优先 | 选没有经过的城市 |
| **总结** | 搜索解 | 都是向量，且不断扩大 |    树    |   跳跃式遍历   | 约束条件回溯判定 |

回溯算法适用于求解**搜索问题**和**优化问题**。

* **搜索空间**：树，节点对应部分解向量，可行解在树叶上

* **搜索过程**：深度、广度优先或其他方法遍历搜索树

* 节点分支判定条件：当不满足约束条件，回溯到该节点的父节点

在搜索过程中，可以用黑白灰三色表示来节点状态：
* 白节点：未访问
* 灰节点：正在访问该节点为根的子树
* 黑节点：该节点为根的子树遍历完成

举个例子，下图是在进行深度优先搜索时，某个时刻的节点状态。

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gungczrpbgj606507maa102.jpg" style="zoom:80%;" />

### 适用条件

能使用回溯算法解决的问题，都满足**多米诺性质**。
$$
P(x_1,\dots,x_{k+1}) \to P(x_1,\dots,x_k) \quad 0 <k<n
$$
及其逆否命题：
$$
\neg P(x_1,\dots,x_{k}) \to \neg P(x_1,\dots,x_{k+1}) \quad 0 <k<n
$$
简单来说，就是当检索到位置$k$时，如果不满足，继续往下肯定也是不满足，此时可以回溯；如果位置$k+1$满足，则它的上一步$k$一定是满足的。

以0-1背包问题为例，有10个物品：当放入1，2，3号物品时已经超重，则后面再继续放肯定也超重，此时需要回溯到2号物品；同理，如果放入1，2，3号时不超重，则只放入1，2号肯定不超重。

### 一个反例

求不等式的整数解：
$$
5x_1+4x_2-x_3 \le 10, \quad 1\le x_1,x_2,x_3 \le 3
$$
因为含有减法，这个问题不满足多米诺性质：
$$
5x_1+4x_2-x_3 \le 10 \nRightarrow 5x_1+4x_2\le 10
$$
可以通过一个变换消除减法，使得其满足多米诺性质：

令 $x_3=3-x_3'$，原问题可以转换为：
$$
5x_1+4x_2+x_3' \le 13, \quad 1 \le x_1,x_3 \le 3, \quad 0 \le x_3' \le 2
$$
此时满足多米诺性质，可以用回溯法解决。

## 回溯算法：递归

```c
ReBack(k) {
  if (k > n)
    return <x1,...,xn> // <x1,...,xn>是解
  while(S_k not empty) {
    x_k = S_k 中的最小值
    S_k = S_k - {x_k}
    ReBack(k+1)
  }
}

ReBacktrack(n) {
 	for(k from 1 to n) {
  	S_k = X_k
  }
  ReBack(1)
}
```

## 装载问题

有$n$个集装箱和两艘轮船，集装箱重量为$w_i$，轮船载重分别为$c_1,c_2$，求装载方案，使得$w_1+w_2+\dots+w_n \le c_1 + c_2$。

举个例子，集装箱和轮船：
$$
W=\{90,80,40,30,20,12,10\}, \quad c_1=152, \quad c_2=130
$$
这个例子的解为：1,3,6,7号装入轮船1，其余装入轮船2。

算法思路：令轮船1的装入量为$W_1$

1. 用回溯算法求使得$c_1 - W_1$达到最小的装载方案
2. 若该方案满足$w_1+\dots+w_n - W_1 \le c_2$，则就是解，否则无解

计算过程：轮船1的最大载重为152，回溯法判断每个集装箱是否放入轮船1的过程如下图：

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1guo7m8umf1j607a0a8aa402.jpg)

可行的方案有两种，但是$c_1-W_1$最小的方案只有如图红线一种。

该算法的时间复杂度为$O(2^n)$。
