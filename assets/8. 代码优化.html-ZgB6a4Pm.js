import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c,a as n,e as t,b as l,d as a}from"./app-BzW9chhs.js";const i={},u=l(`<h1 id="代码优化" tabindex="-1"><a class="header-anchor" href="#代码优化"><span>代码优化</span></a></h1><p>代码优化是指对被优化程序进行的一种<strong>语义保持</strong>的变换。语义保持是指程序的<strong>可观察行为</strong>不能改表，比如程序输出、网络请求等。</p><p>代码优化的目的是让程序体积更小、运行更快等。</p><p>需要注意的是，<strong>不存在“完全优化”</strong>。也就是说，一个程序永远有可以优化的空间。</p><p>编译过程中的优化点：</p><ul><li><p>前期优化</p><p>前期优化主要在抽象语法树上进行。</p><p>比如常量折叠、代数化简、不可达代码删除等。</p></li><li><p>中期优化</p><p>中期优化主要在各个中间表示上进行。</p><p>比如常量传播、拷贝传播、死代码删除、公共子表达式删除等。</p></li><li><p>后期优化</p><p>后期优化在汇编代码上进行。</p><p>比如寄存器分配、指令调度等。</p></li></ul><h2 id="前期优化" tabindex="-1"><a class="header-anchor" href="#前期优化"><span>前期优化</span></a></h2><h3 id="常量折叠" tabindex="-1"><a class="header-anchor" href="#常量折叠"><span>常量折叠</span></a></h3><p>常量折叠简单来说就是：在编译器计算表达式的值。比如：</p><ul><li><code>a = 3 + 5</code> ==&gt; <code>a = 8</code></li><li><code>if (true &amp;&amp; false)</code> ==&gt; <code>if (false)</code></li></ul><p>提前进行这些计算可以减少语法树的节点和后期生成代码的计算。</p><h4 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h4><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">const_fold</span><span class="token punctuation">(</span>Exp e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>e is still shrinking<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swtich</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> EXP_ADD<span class="token operator">:</span>
      	Exp l <span class="token operator">=</span> e<span class="token punctuation">.</span>left<span class="token punctuation">;</span> Exp r <span class="token operator">=</span> e<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
      	<span class="token keyword">if</span> <span class="token punctuation">(</span>
          l<span class="token punctuation">.</span>kind <span class="token operator">==</span> EXP_NUM <span class="token operator">&amp;&amp;</span>
          r<span class="token punctuation">.</span>kind <span class="token operator">==</span> EXP_NUM
        <span class="token punctuation">)</span>
          e <span class="token operator">=</span> new <span class="token function">EXP_NUM</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>value <span class="token operator">+</span> r<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h4><ul><li><p>容易实现，可以在语法树或中间表示上进行</p></li><li><p>通常被实现成<strong>公共子函数</strong>被其他优化调用</p></li><li><p>需要小心遵守语言的语义</p><p>比如<code>0xffffffff + 1 = 0</code>需要根据语言的语义判断是溢出还是抛出异常。</p></li></ul><h3 id="代数化简" tabindex="-1"><a class="header-anchor" href="#代数化简"><span>代数化简</span></a></h3><p>利用代数的性质对程序进行化简。比如：</p><ul><li><code>a = 0 + b</code> ==&gt; <code>a = b</code></li><li><code>a = 1 * b</code> ==&gt; <code>a = b</code></li><li><code>2 * a</code> ==&gt; <code>a + a</code>（加法比乘法简单）</li><li><code>2 * a</code> ==&gt; <code>a &lt;&lt; 1</code>（位运算比乘法简单）</li></ul><h4 id="伪代码-1" tabindex="-1"><a class="header-anchor" href="#伪代码-1"><span>伪代码</span></a></h4><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">alg_simp</span><span class="token punctuation">(</span>Exp e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>e is still shrinking<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> EXP_ADD<span class="token operator">:</span>
        Exp l <span class="token operator">=</span> e<span class="token punctuation">.</span>left<span class="token punctuation">;</span> Exp r <span class="token operator">=</span> e<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>
          l<span class="token punctuation">.</span>kind <span class="token operator">==</span> EXP_NUM <span class="token operator">&amp;&amp;</span>
          l<span class="token punctuation">.</span>value <span class="token operator">==</span> <span class="token number">0</span>
        <span class="token punctuation">)</span>
          e <span class="token operator">=</span> r<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1"><span>小结</span></a></h4><p>代数化简同样要考虑代码的语义。比如：<code>(i - j) + (i - j)</code> ==&gt; <code>i + i + j + j</code>，优化后<code>i + i</code>可能会使程序溢出，而原来的代码不会。</p><h3 id="不可达代码删除" tabindex="-1"><a class="header-anchor" href="#不可达代码删除"><span>不可达代码删除</span></a></h3><p>静态移除程序中不可执行的代码。比如</p><p><code>if (false) s1 else s2</code> ==&gt; <code>s2</code>。</p><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token function">unreachable_code_del</span><span class="token punctuation">(</span>Stm s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>e is still shrinking<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> STM_IF<span class="token operator">:</span>
        Exp e <span class="token operator">=</span> s<span class="token punctuation">.</span>condition<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>kind <span class="token operator">==</span> EXP_FALSE<span class="token punctuation">)</span>
          s <span class="token operator">=</span> s<span class="token punctuation">.</span>elsee
      <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="中期优化" tabindex="-1"><a class="header-anchor" href="#中期优化"><span>中期优化</span></a></h2><p>中期优化主要在各种中间表示上进行，因此依赖于具体的中间表示。比如：</p><ul><li>控制流图（<em>CFG</em>）</li><li>控制依赖图（<em>CDG</em>）</li><li>静态单赋值形式（<em>SSA</em>）</li><li>后序传递风格（<em>CPS</em>）</li></ul><p>共同的特点是<strong>需要进行程序分析</strong>。具体参考上章的<strong>控制流分析</strong>和<strong>数据流分析</strong>。</p><p>下面介绍的都是在<strong>控制流图</strong>上进行的优化。</p>`,31),r=n("p",null,"常量传播",-1),d=n("p",null,"假设有如下控制流图：",-1),k=n("p",null,[a("对这个控制流图进行"),n("strong",null,"到达定义分析"),a("（参考上章）。")],-1),h=n("p",null,[a("如果"),n("code",null,"def: x = 3"),a("是唯一能够到达"),n("code",null,"use: a = x"),a("的，可以将"),n("code",null,"a = x"),a("替换成"),n("code",null,"a = 3"),a("。这是一次常量传播优化。")],-1),m=n("p",null,"拷贝传播",-1),g=n("p",null,"与常量传播优化类似，假设有如下控制流图：",-1),E=n("p",null,[a("如果"),n("code",null,"def: x = y"),a("是唯一能够到达"),n("code",null,"use: a = x"),a("的，可以将"),n("code",null,"a = x"),a("替换成"),n("code",null,"a = y"),a("。这是一次拷贝传播优化。")],-1),f=n("p",null,"死代码删除",-1),_=n("p",null,[a("对这个程序进行"),n("strong",null,"活性分析"),a("（参考上章）。")],-1),x=n("p",null,[a("如果"),n("code",null,"x"),a("的活性区间不持续到"),n("code",null,"return"),a("语句，则可以删除语句"),n("code",null,"x = v"),a("。这是一次死代码删除优化。")],-1);function y(A,v){const s=p("Mermaid");return o(),c("div",null,[u,n("ul",null,[n("li",null,[r,d,t(s,{id:"mermaid-191",code:"eJxli0EOwiAQRfc9xSTd0KQQKTsaXRhvoBdAC5Z0FFLGiLe3iTTGuHz/vX+dTRzhtK8AKETJWIYtqKb5cMeYEGIl9aVzIAo3xsxS59VL4HxXVPn/Lep3QX+fjvRCC5tWth0kmsNk+dMPNGoZc780FzQpHayDwTrzQALnEXXtnGtLr6FWSvXVGzzjOpM="}),k,h]),n("li",null,[m,g,t(s,{id:"mermaid-206",code:"eJxli0EOwiAUBfc9xU+6oQkQKTsaXRhvoBdAC5YUhZRvpLe3iTTGdDlv5t0nHQe4HCsADFEQkmEPc9N8uSWEc76S/NE1IIYHIXqp8+oFMHYoqvw3i/xfvHuOZ5y9gR0VtIWEUxgNe7seByVi7pbm5nVKJ2OhN1a/PIJ13qvaWktLr6CWUnbVB28zOtk="}),E]),n("li",null,[f,t(s,{id:"mermaid-215",code:"eJxljEEOwiAURPc9xU+6oUkhpexodGG8ge6MC7RgSbEQ+NV6e03EGOPyzbyZS1RhgP2mAEAfOCELrOBWVW9uCWGMfUh86eQR/fUQNc5xguaY50DpOnf54C8Rv4mz07jDh9PQ1LxuIWH0o6Z32+MgeVi6l3N2KqWtNtBro2aHYKxzsjTG1NmXUAohuuIJbHI8hg=="}),_,x])])])}const C=e(i,[["render",y],["__file","8. 代码优化.html.vue"]]),B=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8.%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html","title":"代码优化","lang":"zh-CN","frontmatter":{"description":"代码优化 代码优化是指对被优化程序进行的一种语义保持的变换。语义保持是指程序的可观察行为不能改表，比如程序输出、网络请求等。 代码优化的目的是让程序体积更小、运行更快等。 需要注意的是，不存在“完全优化”。也就是说，一个程序永远有可以优化的空间。 编译过程中的优化点： 前期优化 前期优化主要在抽象语法树上进行。 比如常量折叠、代数化简、不可达代码删除等...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/8.%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"代码优化"}],["meta",{"property":"og:description","content":"代码优化 代码优化是指对被优化程序进行的一种语义保持的变换。语义保持是指程序的可观察行为不能改表，比如程序输出、网络请求等。 代码优化的目的是让程序体积更小、运行更快等。 需要注意的是，不存在“完全优化”。也就是说，一个程序永远有可以优化的空间。 编译过程中的优化点： 前期优化 前期优化主要在抽象语法树上进行。 比如常量折叠、代数化简、不可达代码删除等..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代码优化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"前期优化","slug":"前期优化","link":"#前期优化","children":[{"level":3,"title":"常量折叠","slug":"常量折叠","link":"#常量折叠","children":[]},{"level":3,"title":"代数化简","slug":"代数化简","link":"#代数化简","children":[]},{"level":3,"title":"不可达代码删除","slug":"不可达代码删除","link":"#不可达代码删除","children":[]}]},{"level":2,"title":"中期优化","slug":"中期优化","link":"#中期优化","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":3.25,"words":975},"filePathRelative":"计算机基础/编译原理/8. 代码优化.md","localizedDate":"2024年4月12日","autoDesc":true}');export{C as comp,B as data};
