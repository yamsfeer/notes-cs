import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o,c,e as l,b as a,a as n,d as s}from"./app-BzW9chhs.js";const k={},r=a(`<h1 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h1><p>链表相关的问题基本都是双指针解决的，其中快慢指针常用于判断链表是否成环。</p><h2 id="合并、分隔链表" tabindex="-1"><a class="header-anchor" href="#合并、分隔链表"><span>合并、分隔链表</span></a></h2><h3 id="合并两个有序链表-21" tabindex="-1"><a class="header-anchor" href="#合并两个有序链表-21"><span>合并两个有序链表 ( 21 )</span></a></h3><p>将两个有序链表合并为一个新的升序链表并返回。</p><p>这个问题比较简单，类似归并排序的 merge 操作，用两个指针，值小的节点先合并，直到其中一条链表为空，将剩余的节点直接拼接到新链表上。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token parameter">list1<span class="token punctuation">,</span> list2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 虚拟头结点</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> dummy

  <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      p<span class="token punctuation">.</span>next <span class="token operator">=</span> list1
      list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      p<span class="token punctuation">.</span>next <span class="token operator">=</span> list2
      list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token comment">// 当其中一条链表检查完，拼接另一条（可能也为空）</span>
  p<span class="token punctuation">.</span>next <span class="token operator">=</span> list1 <span class="token operator">?</span> list1 <span class="token operator">:</span> list2
  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre></div><p>代码中用到了链表算法题中常见的虚拟头结点 ( dummy ) 技巧，有了 dummy 节点作为占位符，可以避免出现空指针。</p><p><strong>每当你需要创建一条新链表时，建议都使用 dummy 节点，可以减少很多麻烦。</strong></p><h3 id="合并-k-个有序链表-23" tabindex="-1"><a class="header-anchor" href="#合并-k-个有序链表-23"><span>合并 k 个有序链表 ( 23 )</span></a></h3><p>这是面试常考题。整体思路与“合并两个有序链表”是一样的，问题在于，如何快速找到 k 个链表的最小节点，答案是<strong>优先级队列 ( 最小堆 )</strong>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span><span class="token parameter">lists</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>

  <span class="token comment">// 优先级队列， 值越小，优先级越高</span>
  <span class="token keyword">const</span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>val <span class="token operator">-</span> b<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token comment">// 将 k 个链表的头结点加入队列</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> list <span class="token keyword">of</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list <span class="token operator">&amp;&amp;</span> qp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> dummy

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> min <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// k 个链表的最小节点</span>
    min<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>min<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token comment">// 持续将链表节点推入队列</span>

    p<span class="token punctuation">.</span>next <span class="token operator">=</span> min
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre></div>`,12),u=n("p",null,[s("优先队列中元素的个数最多有 k 个，每次优先队列添加或删除节点的时间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"k"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logk)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),n("span",{class:"mclose"},")")])])]),s("，链表中的每个节点都会加入和弹出队列。因此，整个算法的时间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"k"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(nlogk)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),n("span",{class:"mclose"},")")])])]),s("。")],-1),i=a(`<h3 id="分隔链表-86" tabindex="-1"><a class="header-anchor" href="#分隔链表-86"><span>分隔链表 ( 86 )</span></a></h3><p>给定一个链表和特定值 x，分隔链表使得小于 x 的节点都在左边，大于等于 x 的在右边。</p><p>上一题是归并排序的 merge 操作，这一题是快速排序的 partition 操作。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dummy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> dummy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> head<span class="token punctuation">,</span> p1 <span class="token operator">=</span> dummy1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> dummy2

  <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      p1<span class="token punctuation">.</span>next <span class="token operator">=</span> p
      p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p
      p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
    <span class="token comment">// 断开原链表的连接</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> p<span class="token punctuation">.</span>next
    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>
    p <span class="token operator">=</span> temp
  <span class="token punctuation">}</span>
  l1<span class="token punctuation">.</span>next <span class="token operator">=</span> dummy2<span class="token punctuation">.</span>next <span class="token comment">// 连接两个子链表</span>

  <span class="token keyword">return</span> dummy1<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre></div><p>这道题中虚拟头结点的作用就很明显了，没有虚拟头结点，就需要各种空指针的判断，代码会复杂很多。</p><h2 id="链表的第-k-节点" tabindex="-1"><a class="header-anchor" href="#链表的第-k-节点"><span>链表的第 k 节点</span></a></h2><h3 id="倒数第-k-个" tabindex="-1"><a class="header-anchor" href="#倒数第-k-个"><span>倒数第 k 个</span></a></h3><p>假设一个链表有 n 个节点，那么倒数第 k 节点就是顺数第 <code>n - k + 1</code> 节点。然而，链表的长度通常是未知的，我们需要先遍历一遍链表得到 n，再遍历 <code>n - k + 1</code> 次找到倒数第 k 个节点。</p><p>上述做法需要遍历两次，用双指针技巧只需遍历一次。</p><ol><li>左指针不动，右指针往前走 k 步，左右指针形成长度为 k + 1 的区间</li><li>左右指针同时移动，直到右指针到达尾部 null 节点，左指针正好是倒数第 k 个节点</li></ol><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/链表-倒数第k个节点.svg" alt=""></p><p>实现代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">findFromEnd</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> l <span class="token operator">=</span> head<span class="token punctuation">,</span> r <span class="token operator">=</span> head
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">=</span> r<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l <span class="token operator">=</span> l<span class="token punctuation">.</span>next
    r <span class="token operator">=</span> r<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> l
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除倒数第-k-个-19" tabindex="-1"><a class="header-anchor" href="#删除倒数第-k-个-19"><span>删除倒数第 k 个 ( 19 )</span></a></h3><p>有了上述 <code>findFromEnd</code> 函数后，要删除倒数第 k 个节点就比较容易了，只需找到倒数第 k + 1 个节点，然后删除下一个节点即可。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span>

  <span class="token comment">// 删除倒数第 k 个，需要找到倒数第 k + 1 个节点</span>
  <span class="token keyword">const</span> prev <span class="token operator">=</span> <span class="token function">findFromEnd</span><span class="token punctuation">(</span>dummy<span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  prev<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token comment">// 删除节点</span>

  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre></div><p>代码中虚拟头结点也是为了防止出现空指针。假如要删除的是第 1 个节点，那么它的前一个节点是不存在的，虚拟头结点可以解决这个问题。</p><h2 id="链表的快慢指针" tabindex="-1"><a class="header-anchor" href="#链表的快慢指针"><span>链表的快慢指针</span></a></h2><h3 id="链表的中点-876" tabindex="-1"><a class="header-anchor" href="#链表的中点-876"><span>链表的中点 ( 876 )</span></a></h3><p>在不知道链表长度的情况下，要找出链表的中间节点，需要用到快慢指针。</p><ol><li>slow、fast 指针指向头结点 head</li><li>slow 每次前进 1 步，fast 每次前进 2 步</li><li>当 fast 到达尾部 null 节点，slow 则指向中间节点</li></ol><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slow
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意的是，如果链表长度为偶数，说明有两个中间节点，快慢指针算法得到的是后一个中间节点。</p><h3 id="判断链表是否包含环" tabindex="-1"><a class="header-anchor" href="#判断链表是否包含环"><span>判断链表是否包含环</span></a></h3><p>快慢指针对判断链表是否成环非常有用。</p><ul><li>如果链表没有环，fast 到达尾部时，slow 会指向中点</li><li>如果链表含有环，slow、fast 指针最终会相遇</li></ul><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next

    <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">===</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 两指针相遇</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// fast 能到达尾部，说明没有环</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="链表环的起点" tabindex="-1"><a class="header-anchor" href="#链表环的起点"><span>链表环的起点</span></a></h3><p>算法思路：当快慢指针相遇时，让 slow 或 fast 指针指向头结点，然后 slow、fast 同速前进，再次相遇的位置就是环的起点。</p><p>算法原理：</p><ol><li>假设双指针第一次相遇时，slow 走了 k 步，fast 则走了 2k 步</li></ol><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/3.jpeg" style="zoom:33%;"><ol start="2"><li>设相遇点距离环起点距离为 m，由 slow 只走了 k 步，可推出 head 到环起点的距离为 <code>k - m</code></li></ol><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/2.jpeg" style="zoom:33%;"><ol start="3"><li><p>fast 第一次经过相遇点时已走了 k 步 ( slow 未赶到 )，再走 k 步会再次到达相遇点 ( slow 赶到 )。因此，fast 在相遇点再走 k - m 步会到达环起点</p></li><li><p>结合第 2 第 3 点可知，将 slow 或 fast 重新指向 head，两个指针同步前进，<code>k - m</code> 步后一定会在环起始点相遇</p></li></ol><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head

  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">===</span> fast<span class="token punctuation">)</span> <span class="token keyword">break</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 没有坏</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>

  slow <span class="token operator">=</span> head <span class="token comment">// 其中一个指针重新走</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span>slow ！<span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slow
<span class="token punctuation">}</span>
</code></pre></div><p>顺便说一句，fast 比 slow 多走的 k 步其实是 fast 在环内转圈，所以 k 是环长度的整数倍。</p><p>总结一下，快慢指针第一次相遇说明有环，同速前进相遇找到环起点。</p><p>以上做法的证明比较麻烦，我们可以借助额外空间使这个问题变简单。</p><p>我们用一个集合保存所有访问过的节点，当出现访问过的节点，这个节点就是起点。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> head
    <span class="token punctuation">}</span>
    visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="相交链表-160" tabindex="-1"><a class="header-anchor" href="#相交链表-160"><span>相交链表 ( 160 )</span></a></h2><p>给定两个链表的头结点 headA 和 headB，如果两个链表相交，返回相交节点，不相交则返回 null。</p><p>比如下面的两个链表相交于 c1 节点。</p>`,44),d=a(`<p>如果使用常见的双指针技巧，p1 和 p2 两个指针分别在两条链表上前进，并不能同时走到公共节点。</p><p>解决这个问题的关键在于：通过某种方式，让 p1、p2 同时到达相交节点。</p><p>我们让 p1 遍历完链表 A 后开始遍历链表 B，p2 遍历完链表 B 后开始遍历链表 A。</p><p>其实这样相当于将两条链表首尾连在一起，这样它们的长度就一样了，最终它们会在相交点相遇。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token parameter">headA<span class="token punctuation">,</span> headB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p1 <span class="token operator">=</span> headA<span class="token punctuation">,</span> p2 <span class="token operator">=</span> headB
  <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!==</span> <span class="token constant">P2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		p1 <span class="token operator">=</span> p1 <span class="token operator">===</span> <span class="token keyword">null</span>
      <span class="token operator">?</span> headB <span class="token comment">// p1 到达末尾，转到 B 链表</span>
    	<span class="token operator">:</span> p1<span class="token punctuation">.</span>next
		p2 <span class="token operator">=</span> p2 <span class="token operator">===</span> <span class="token keyword">null</span>
      <span class="token operator">?</span> headA <span class="token comment">// p2 到达末尾，转到 A 链表</span>
    	<span class="token operator">:</span> p2<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> p1
<span class="token punctuation">}</span>
</code></pre></div>`,5),m=n("p",null,[s("这种做法时间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，空间复杂度 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),s("。")],-1),h=n("p",null,"另一种解法是将两条链表首尾相连，如果两条链表不相交，它们会形成一条单链表，快慢指针会很快结束；如果两条链表相交，则会形成一个环，这就回到了前面寻找环起点的问题。",-1),w=n("p",null,"还有一种思路是：先计算两条链表的长度，然后让它们右对齐，即长的先遍历，直到长度相同，然后同时前进，如果它们相交，则会同时到达相交点。",-1);function y(g,f){const t=e("Mermaid");return o(),c("div",null,[r,u,i,l(t,{id:"mermaid-198",code:"eJw9zcEOgjAMBuAze4omXCApidv0Aoknj570Cda5ycKihC1B394q4GXrn35t75MZezhfRGFkVRlZ19A0RzCKg1qD5Y7ljiiIK9oMsaHNkOag/wPLx8AyEAA2mpROzsPch+zAhxjb0nuPkPL0HFwLpda6YxnDY7jmd3SwQ4kKNe7xsKpmDrfct3J8feVvJxiJRiFJJH41WolWLVc68QEh6zk3"}),d,m,h,w])}const j=p(k,[["render",y],["__file","2.链表.html.vue"]]),b=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/2.%E9%93%BE%E8%A1%A8.html","title":"链表","lang":"zh-CN","frontmatter":{"description":"链表 链表相关的问题基本都是双指针解决的，其中快慢指针常用于判断链表是否成环。 合并、分隔链表 合并两个有序链表 ( 21 ) 将两个有序链表合并为一个新的升序链表并返回。 这个问题比较简单，类似归并排序的 merge 操作，用两个指针，值小的节点先合并，直到其中一条链表为空，将剩余的节点直接拼接到新链表上。 代码中用到了链表算法题中常见的虚拟头结点 ...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/2.%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"链表"}],["meta",{"property":"og:description","content":"链表 链表相关的问题基本都是双指针解决的，其中快慢指针常用于判断链表是否成环。 合并、分隔链表 合并两个有序链表 ( 21 ) 将两个有序链表合并为一个新的升序链表并返回。 这个问题比较简单，类似归并排序的 merge 操作，用两个指针，值小的节点先合并，直到其中一条链表为空，将剩余的节点直接拼接到新链表上。 代码中用到了链表算法题中常见的虚拟头结点 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%93%BE%E8%A1%A8-%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"链表\\",\\"image\\":[\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%93%BE%E8%A1%A8-%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.svg\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"合并、分隔链表","slug":"合并、分隔链表","link":"#合并、分隔链表","children":[{"level":3,"title":"合并两个有序链表 ( 21 )","slug":"合并两个有序链表-21","link":"#合并两个有序链表-21","children":[]},{"level":3,"title":"合并 k 个有序链表 ( 23 )","slug":"合并-k-个有序链表-23","link":"#合并-k-个有序链表-23","children":[]},{"level":3,"title":"分隔链表 ( 86 )","slug":"分隔链表-86","link":"#分隔链表-86","children":[]}]},{"level":2,"title":"链表的第 k 节点","slug":"链表的第-k-节点","link":"#链表的第-k-节点","children":[{"level":3,"title":"倒数第 k 个","slug":"倒数第-k-个","link":"#倒数第-k-个","children":[]},{"level":3,"title":"删除倒数第 k 个 ( 19 )","slug":"删除倒数第-k-个-19","link":"#删除倒数第-k-个-19","children":[]}]},{"level":2,"title":"链表的快慢指针","slug":"链表的快慢指针","link":"#链表的快慢指针","children":[{"level":3,"title":"链表的中点 ( 876 )","slug":"链表的中点-876","link":"#链表的中点-876","children":[]},{"level":3,"title":"判断链表是否包含环","slug":"判断链表是否包含环","link":"#判断链表是否包含环","children":[]},{"level":3,"title":"链表环的起点","slug":"链表环的起点","link":"#链表环的起点","children":[]}]},{"level":2,"title":"相交链表 ( 160 )","slug":"相交链表-160","link":"#相交链表-160","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":7.23,"words":2168},"filePathRelative":"编程/leetcode/2.链表.md","localizedDate":"2024年4月12日","autoDesc":true}');export{j as comp,b as data};
