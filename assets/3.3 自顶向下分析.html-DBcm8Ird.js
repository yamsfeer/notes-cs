import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as l,a,d as s,b as n}from"./app-BzW9chhs.js";const p={},o=a("h1",{id:"自顶向下分析",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#自顶向下分析"},[a("span",null,"自顶向下分析")])],-1),c=a("p",null,[s("语法分析的作用之一，相当于给定文法"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("和句子"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),s("，判断"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("能否推导出"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),s("。")],-1),i=a("p",null,"为实现这个判断，我们可以：",-1),m=a("ul",null,[a("li",null,[s("从"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("的开始符号出发，每推导出一个句子，就和"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),s("做一次比较")]),a("li",null,[s("如果相等，结束推导，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("可以推导出"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])])]),a("li",null,[s("如果不相等，继续推导直到相等或完成全部推导，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("不能推导出"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])])])],-1),r=n('<p>该过程是从开始符号出发推出句子，因此称为<strong>自顶向下分析</strong>。</p><p><strong>自顶向下分析</strong>对应<strong>分析树自顶向下的构造顺序</strong>。</p><h2 id="自顶向下分析的例子" tabindex="-1"><a class="header-anchor" href="#自顶向下分析的例子"><span>自顶向下分析的例子</span></a></h2><p>举个自顶向下分析的例子（依旧是<code>主谓宾</code>的例子）：</p>',4),h=a("ol",null,[a("li",null,[a("p",null,[s("给定文法"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("：")]),a("div",{class:"language-text","data-ext":"text","data-title":"text"},[a("pre",{class:"language-text"},[a("code",null,`S -> N V N
N -> s
   | t
   | g
   | w
V -> e
   | d
`)])]),a("p",null,[s("推导句子"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),s(" = "),a("code",null,"g d w"),s("。")])]),a("li",null,[a("p",null,[s("我们选择"),a("code",null,"最左推导"),s("，一次可能的推导过程如下：")]),a("div",{class:"language-text","data-ext":"text","data-title":"text"},[a("pre",{class:"language-text"},[a("code",null,`S -> N V N 
  -> s V N 
  -> s e N
  -> s e t
`)])]),a("p",null,"此次推导结果与句子不等，进行下一次推导。")]),a("li",null,[a("p",null,"若干次尝试后，我们最终可以得到正确的推导过程"),a("div",{class:"language-text","data-ext":"text","data-title":"text"},[a("pre",{class:"language-text"},[a("code",null,`S -> N V N
  -> g V N
  -> g d N 
  -> g d w
`)])]),a("p",null,[s("结束推导，"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("可以推导出"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"S")]),a("annotation",{encoding:"application/x-tex"},"S")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),s("。")])])],-1),u=n(`<p>很明显，我们不需要推导出整个句子后才与目标句子比较。</p><p>比如在第2步的推导中，当推导出第一个终结符<code>s</code>时，即可判断与目标句子的<code>g</code>不相等。</p><p>因此，我们做出如下改进：</p><ul><li>每得到一个终结符，与所需要匹配的句子里面相应的字符进行比较</li><li>如果不相等，回溯，进行下一次推导</li></ul><p>算法过程伪代码如下：</p><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code>tokens<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// all tokens</span>
i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
stack <span class="token operator">=</span> <span class="token punctuation">[</span>S<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// S 是开始符号</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>stack not empty<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> is a terminal t<span class="token punctuation">)</span> <span class="token comment">//栈顶是终结符</span>
    t <span class="token operator">==</span> tokens<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span>
    	<span class="token operator">?</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	<span class="token operator">:</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 终结符与目标字符不等，回溯</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> is a nonterminal T<span class="token punctuation">)</span> <span class="token comment">//栈顶是非终结符</span>
    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">/* 选择哪个压栈会在LL分析算法里讲解
		   本节先将T的右边压栈 */</span>
    <span class="token function">push</span><span class="token punctuation">(</span>the next right hand side of T<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="算法的讨论" tabindex="-1"><a class="header-anchor" href="#算法的讨论"><span>算法的讨论</span></a></h2><p>上述自顶向下分析过程改进后的效率仍不能使人满意。为了编译上千万行的内核等程序，编译器必须足够高效。</p><p>实际上，我们需要<strong>线性时</strong>间的算法。为此，需要<strong>避免回溯</strong>。</p><p>这里引出<strong>递归下降分析算法</strong>和<strong>LL(1)分析算法</strong>。</p>`,10),d=[o,c,i,m,r,h,u];function k(g,x){return e(),l("div",null,d)}const y=t(p,[["render",k],["__file","3.3 自顶向下分析.html.vue"]]),_=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.3%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90.html","title":"自顶向下分析","lang":"zh-CN","frontmatter":{"description":"自顶向下分析 语法分析的作用之一，相当于给定文法G和句子S，判断G能否推导出S。 为实现这个判断，我们可以： 从G的开始符号出发，每推导出一个句子，就和S做一次比较 如果相等，结束推导，G可以推导出S 如果不相等，继续推导直到相等或完成全部推导，G不能推导出S 该过程是从开始符号出发推出句子，因此称为自顶向下分析。 自顶向下分析对应分析树自顶向下的构造...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.3%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"自顶向下分析"}],["meta",{"property":"og:description","content":"自顶向下分析 语法分析的作用之一，相当于给定文法G和句子S，判断G能否推导出S。 为实现这个判断，我们可以： 从G的开始符号出发，每推导出一个句子，就和S做一次比较 如果相等，结束推导，G可以推导出S 如果不相等，继续推导直到相等或完成全部推导，G不能推导出S 该过程是从开始符号出发推出句子，因此称为自顶向下分析。 自顶向下分析对应分析树自顶向下的构造..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"自顶向下分析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"自顶向下分析的例子","slug":"自顶向下分析的例子","link":"#自顶向下分析的例子","children":[]},{"level":2,"title":"算法的讨论","slug":"算法的讨论","link":"#算法的讨论","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":2.1,"words":629},"filePathRelative":"计算机基础/编译原理/3.3 自顶向下分析.md","localizedDate":"2024年4月12日","autoDesc":true}');export{y as comp,_ as data};
