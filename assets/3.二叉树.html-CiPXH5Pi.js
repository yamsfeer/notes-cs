import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as e,e as a,b as n}from"./app-BzW9chhs.js";const c={},l=n(`<h1 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h1><p>二叉树遍历框架：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token comment">// 前序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token comment">// 中序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>traverse</code> 就是一个能够访问二叉树所有节点的函数，和遍历数组、链表没有本质区别，<strong>二叉树其实就是二叉链表</strong>。</p><p>事实上，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 递归遍历单链表</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 前序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
  <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="前中后序" tabindex="-1"><a class="header-anchor" href="#前中后序"><span>前中后序</span></a></h2><p>前中后序是指二叉树遍历过程中处理每个节点的三个特殊时间点，这三个位置的代码<strong>执行时机不同</strong>。</p><ul><li><p>前序位置代码：刚进入节点时执行</p></li><li><p>后序位置代码：将要离开节点时执行</p></li><li><p>中序位置代码：左子树都遍历完，即将开始遍历右子树时执行</p></li></ul><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/2-20230420020337934.jpeg" style="zoom:30%;"><p><strong>解决二叉树的所有问题，就是在前中后序位置注入代码逻辑</strong>。你只需要单独思考每一个节点应该做什么，其他的不用管，递归会在所有节点上执行相同的操作。</p><h2 id="两种解题思路" tabindex="-1"><a class="header-anchor" href="#两种解题思路"><span>两种解题思路</span></a></h2><p>二叉树的最大深度 ( 104 ) ：求根节点到最远叶子节点的最长路径上的节点数。比如下图中二叉树的最大深度为 3。</p>`,13),u=n(`<p>以这题为例，介绍两种二叉树的解题思路。</p><h3 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h3><p>遍历思路：用 <code>traverse</code> 函数遍历二叉树，用外部变量记录每个节点当前的深度，遇到叶子结点，说明已到达当前路径最大深度。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> maxDepth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> depth <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  depth<span class="token operator">++</span> <span class="token comment">// 前序位置</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 叶子结点</span>
    maxDepth <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxDepth<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  depth<span class="token operator">--</span> <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">return</span> maxDepth
<span class="token punctuation">}</span>
</code></pre></div><p>前序位置代码是 <code>depth++</code>，后序位置代码是 <code>depth--</code>。当访问到一个新节点时，深度是增加的，离开这个节点时，深度是减小的。这符合上面我们介绍的三种代码执行时机。</p><h3 id="分解问题" tabindex="-1"><a class="header-anchor" href="#分解问题"><span>分解问题</span></a></h3><p>一棵树的最大深度可以通过子树的最大深度推导出来，即 <code>depth = max(lDepth, rDepth) + 1</code>。</p><p>这样一来，整棵树的问题分解成了子树最大深度的问题。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

  <span class="token comment">// 后序位置</span>
  <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>和遍历解法不同，分解问题解法的主要逻辑在后序位置，这是因为我们左右子树需要先计算完成。凡是依赖子树解的问题，都是在后序位置操作，后面一节会介绍。</p><h3 id="两种思路的异同" tabindex="-1"><a class="header-anchor" href="#两种思路的异同"><span>两种思路的异同</span></a></h3><ul><li><p>相同点</p><p>两种做法都需要通过递归遍历每个节点，且都逃不出前中后序位置。</p></li><li><p>不同点</p><ul><li>第一种是在遍历过程中，<strong>操作外部变量做记录</strong></li><li>第二种是将问题分解成子问题，最主要的是，<strong>递归函数的返回值就是问题或子问题的解</strong>。</li></ul></li></ul><p>下面用二叉树的先序遍历序列对比一下两种思路。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 外部变量</span>

  <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment">// 外部变量记录，前序位置</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token comment">// 遍历</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 返回值就是子问题的解</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token operator">...</span>left<span class="token punctuation">,</span> <span class="token operator">...</span>right<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="后序位置的特殊性" tabindex="-1"><a class="header-anchor" href="#后序位置的特殊性"><span>后序位置的特殊性</span></a></h2><p>前序位置本身并不特别，只是我们习惯把前中后序位置不敏感的代码写在前序位置。</p><p>中序位置主要用在 BST 中，BST 的中序遍历就是遍历有序数组。</p><p>思考一下遍历过程可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码是自底向上的。</p><p>这意味着前序位置只能从函数参数中获取父节点传递来的数据，而后序位置除了参数，还能获取子树的函数返回值。</p><p>来对比两个小问题：</p><ul><li><p>获取每一个节点所在的层数</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> level</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token comment">// 前序，只能得到 root.val 和 level</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 将当前层级传给子级</span>
</code></pre></div></li><li><p>计算每个节点的左右子树的节点数</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>

  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token comment">// 后序，左右子树已经计算完成</span>
  <span class="token keyword">return</span> left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul><p>这两个问题的区别在于：节点在第几层，你从根节点遍历过来的过程就能顺带记录；而树有多少个节点，你需要遍历完左右子树之后才能数清楚。</p><p><strong>能获取子树的信息，这就是后序位置的特殊之处</strong>。</p><p>换句话说，一旦题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码。</p><p>来看以下后序位置在实际题目中的应用。</p><h3 id="二叉树的直径-543" tabindex="-1"><a class="header-anchor" href="#二叉树的直径-543"><span>二叉树的直径 ( 543 )</span></a></h3><p>计算二叉树的直径长度。直径长度是指：任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>`,28),r=n(`<p>上图的直径长度是 3，路径为 <code>[4,2,1,3],[5,2,1,3]</code> 这两种。</p><p>这题的关键在于，<strong>每一条直径长度，就是一个节点的左右子树的最大深度之和</strong>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> maxDiameter <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">function</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token comment">// 后序位置，计算最大深度，顺便计算最大直径</span>
    maxDiameter <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">,</span> maxDiameter<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历"><span>层序遍历</span></a></h2><p>二叉树题型主要是用来培养递归思维的，层序遍历则属于迭代遍历。</p><p>层序遍历的代码框架：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">levelTraverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token keyword">const</span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从上到下遍历二叉树的每一层</span>
    <span class="token keyword">let</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从左到右遍历当前一层节点</span>
      <span class="token keyword">const</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
      cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment">// 访问当前节点</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>while 循环表示从上到下、for 循环表示从左到右遍历节点：</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5rej337cyj20zk0k0q4i.jpg" style="zoom:40%;"><h2 id="二叉树的重要性" tabindex="-1"><a class="header-anchor" href="#二叉树的重要性"><span>二叉树的重要性</span></a></h2><p>二叉树思想的运用非常广泛，可以说，<strong>只要涉及递归，都可以抽象成二叉树的问题</strong>。</p><p>比如快速排序，其实它是二叉树的前序遍历。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前序位置</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

  <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>又比如归并排序，它其实是二叉树的后序遍历。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lo <span class="token operator">+</span> hi<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
  <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

  <span class="token comment">// 后序位置</span>
  <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token comment">// 前序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token comment">// 中序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
</code></pre></div><p>前中后序是指二叉树遍历过程中处理每个节点的三个特殊时间点。</p><p>后序位置比较特殊，它可以通过函数的返回值获取子树的信息，这可以用来解决很多问题。</p><p>二叉树解题的思维模式有两种：遍历、分解问题</p><ul><li><p>遍历：<strong>是否可以遍历一次二叉树得到答案？</strong></p><p>如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现</p></li><li><p>分解问题：<strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong></p><p>如果可以，写出这个递归函数的定义，并充分利用函数的返回值</p></li></ul><p>无论使用哪种思维模式，你都需要思考：</p><p><strong>单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用操心，递归函数会帮你在所有节点上执行相同的操作。</p>`,23);function k(i,d){const s=p("Mermaid");return o(),e("div",null,[l,a(s,{id:"mermaid-47",code:"eJxNjEEKwjAQAM/2FQu9bGALSZZS2oIH8Qf6gaKJDQ1amkD196bRQ48zDPNYhnmE66k4MCILAVV1hBaxFSKpTFoiarmxllmoGlHVO9EgNgkLgJsfQjgbC+voogHrvO9Kay1BiMtrMh2UzNyn0rvndIkfb0CSIk38L6rV3ePYqfm9VfkHTC3plNXU/MZ98QUFXy3Y"}),u,a(s,{id:"mermaid-159",code:"eJxFzMEKAiEQxvFz+xQDexlBIR29uNAheoN6gaU0ZaWWVdh6+1wLOv5m/nz3ZZwDXI7dTiJKxkCIAyhExVg9NREibVJNGlH/ZRBNVQdwTWPOJ+dhDbE48DEl23vvOeSyPCdnoSeioZYpPqZzeScHey654vQrxBpvJVg5v7aq7UH7c83Nd3boPtKhLDI="}),r])}const f=t(c,[["render",k],["__file","3.二叉树.html.vue"]]),g=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/3.%E4%BA%8C%E5%8F%89%E6%A0%91.html","title":"二叉树","lang":"zh-CN","frontmatter":{"description":"二叉树 二叉树遍历框架： traverse 就是一个能够访问二叉树所有节点的函数，和遍历数组、链表没有本质区别，二叉树其实就是二叉链表。 事实上，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。 前中后序 前中后序是指二叉树遍历过程中处理每个节点的三个特殊时间点，这三个位置的代码执行时机不同。 前序位置代码：刚进入节点时执行...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/3.%E4%BA%8C%E5%8F%89%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"二叉树"}],["meta",{"property":"og:description","content":"二叉树 二叉树遍历框架： traverse 就是一个能够访问二叉树所有节点的函数，和遍历数组、链表没有本质区别，二叉树其实就是二叉链表。 事实上，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。 前中后序 前中后序是指二叉树遍历过程中处理每个节点的三个特殊时间点，这三个位置的代码执行时机不同。 前序位置代码：刚进入节点时执行..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"前中后序","slug":"前中后序","link":"#前中后序","children":[]},{"level":2,"title":"两种解题思路","slug":"两种解题思路","link":"#两种解题思路","children":[{"level":3,"title":"遍历","slug":"遍历","link":"#遍历","children":[]},{"level":3,"title":"分解问题","slug":"分解问题","link":"#分解问题","children":[]},{"level":3,"title":"两种思路的异同","slug":"两种思路的异同","link":"#两种思路的异同","children":[]}]},{"level":2,"title":"后序位置的特殊性","slug":"后序位置的特殊性","link":"#后序位置的特殊性","children":[{"level":3,"title":"二叉树的直径 ( 543 )","slug":"二叉树的直径-543","link":"#二叉树的直径-543","children":[]}]},{"level":2,"title":"层序遍历","slug":"层序遍历","link":"#层序遍历","children":[]},{"level":2,"title":"二叉树的重要性","slug":"二叉树的重要性","link":"#二叉树的重要性","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":7.02,"words":2106},"filePathRelative":"编程/leetcode/3.二叉树.md","localizedDate":"2024年4月12日","autoDesc":true}');export{f as comp,g as data};
