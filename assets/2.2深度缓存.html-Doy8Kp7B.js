import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,b as e}from"./app-BzW9chhs.js";const s={},o=e(`<h1 id="深度缓冲-z-buffing" tabindex="-1"><a class="header-anchor" href="#深度缓冲-z-buffing"><span>深度缓冲 ( Z-buffing )</span></a></h1><p>场景中有许多物体，它们之间会有遮挡 <em>( occlusion )</em>，区分物体的前后是个问题。</p><p><strong>画家算法</strong> <em>( Painter&#39;s Algorithm )</em> 是油画的画法：先画远处的物体，然后画近处的物体，从而覆盖远处的物体形成远近关系。</p><p>画家算法的时间复杂度是 <em>nlogn</em>，相当于对 n 个三角形进行排序。</p><p>一般的遮挡问题可以用画家算法解决，比如远处的山、中间的树、近处的人。</p><p>当遮挡情况复杂时，画家算法就无法解决了。比如下面这种互相遮挡的情况。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h3o8mphh8ij20hg0eqjrq.jpg" alt="image-20220628203554530" style="zoom:45%;"><p>z-buffing 算法可以解决这个问题。</p><h2 id="z-buffing" tabindex="-1"><a class="header-anchor" href="#z-buffing"><span>z-buffing</span></a></h2><p>z-buffing 又名 depth-buffer，该算法针对图像每一个像素都记录一个深度值 zbuffer，它是物体像素与相机的距离，在同一位置要渲染新像素时，</p><ul><li>如果深度值大于 zbuffer，说明它被覆盖了，不用渲染。</li><li>如果小于 zbuffer，说明它距离相机更近，覆盖了其他像素，需要渲染且更新 zbuffer</li><li>如果相等，称为 z-fighting</li></ul><p>在图形学中，一张图像需要两个 buffer：</p><ul><li>frame buffer，存储像素的 color values</li><li>depth buffer ( z-buffer )，存储任何一个像素看到的几何物体的最浅深度信息</li></ul><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h3o8mohetjj211u0gm75u.jpg" alt="image-20220628203643112" style="zoom:40%;"><p>从算法来讲，一开始所有的像素的深度都认为是<strong>无限远</strong>的，三角形光栅化为像素后，每个像素的深度 ( z 的绝对值 ) 都是已知的，我们需要对所有三角形的所有像素循环，将当前深度与 buffer 中的深度对比。</p><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>each triangle T<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>each <span class="token function">sample</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> in T<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">&lt;</span> zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// closest sample so far</span>
      framebuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> rgb<span class="token punctuation">;</span> <span class="token comment">// update color</span>
      zbuffer<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span> <span class="token comment">// update depth</span>
    <span class="token keyword">else</span> <span class="token comment">// do nothing, this sample is occluded</span>
</code></pre></div><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h3o8mn99gkj20ty0j0q7s.jpg" alt="image-20220628203721603" style="zoom:50%;"><p>如果两个像素的深度值恰好完全相同，由于渲染时无法判断遮挡情况，深度相同的位置会出现闪烁现象，这就是 z-fighting。</p><p>在图形学中或几何的表示方法里，很多数字都是用浮点型表示的。由于浮点型数据的误差，基本上可以认为两个浮点型的数字永远也不会相同。</p><p>如果恰巧遇到 z-fighting，可以有两个方式解决：</p><ul><li>调整模型，使其不在同一个像素出现相同深度值</li><li>人为设置渲染顺序，这样即使出现相同深度值，也能正确渲染</li></ul>`,21),p=[o];function c(i,l){return t(),a("div",null,p)}const m=n(s,[["render",c],["__file","2.2深度缓存.html.vue"]]),f=JSON.parse(`{"path":"/%E5%9B%BE%E5%BD%A2%E5%AD%A6/games101/2.2%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%AD%98.html","title":"深度缓冲 ( Z-buffing )","lang":"zh-CN","frontmatter":{"description":"深度缓冲 ( Z-buffing ) 场景中有许多物体，它们之间会有遮挡 ( occlusion )，区分物体的前后是个问题。 画家算法 ( Painter's Algorithm ) 是油画的画法：先画远处的物体，然后画近处的物体，从而覆盖远处的物体形成远近关系。 画家算法的时间复杂度是 nlogn，相当于对 n 个三角形进行排序。 一般的遮挡问题可...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E5%9B%BE%E5%BD%A2%E5%AD%A6/games101/2.2%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"深度缓冲 ( Z-buffing )"}],["meta",{"property":"og:description","content":"深度缓冲 ( Z-buffing ) 场景中有许多物体，它们之间会有遮挡 ( occlusion )，区分物体的前后是个问题。 画家算法 ( Painter's Algorithm ) 是油画的画法：先画远处的物体，然后画近处的物体，从而覆盖远处的物体形成远近关系。 画家算法的时间复杂度是 nlogn，相当于对 n 个三角形进行排序。 一般的遮挡问题可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深度缓冲 ( Z-buffing )\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"z-buffing","slug":"z-buffing","link":"#z-buffing","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":2.24,"words":673},"filePathRelative":"图形学/games101/2.2深度缓存.md","localizedDate":"2024年4月12日","autoDesc":true}`);export{m as comp,f as data};
