import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,b as t}from"./app-BzW9chhs.js";const p={},e=t(`<h1 id="反转链表" tabindex="-1"><a class="header-anchor" href="#反转链表"><span>反转链表</span></a></h1><h2 id="迭代反转-206" tabindex="-1"><a class="header-anchor" href="#迭代反转-206"><span>迭代反转 ( 206 )</span></a></h2><p>给定一个链表的头结点，返回反转整个链表后的头结点。</p><p>如果用迭代方式反转，代码大概如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> head <span class="token comment">// 双指针</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev <span class="token comment">// 反转</span>
    prev <span class="token operator">=</span> cur <span class="token comment">// 更新指针</span>
    cur <span class="token operator">=</span> next
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相比于迭代，递归操作链表并不高效，因为递归需要 O(n) 的空间复杂度。我们着重了解链表天然的递归特性即可。</p><h2 id="递归反转-206" tabindex="-1"><a class="header-anchor" href="#递归反转-206"><span>递归反转 ( 206 )</span></a></h2><p>如果用递归实现反转链表，代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 有一个或0个节点都直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> head
  <span class="token punctuation">}</span>

  <span class="token comment">// 除 head 外，反转其余节点，返回反转后的头结点</span>
  <span class="token keyword">const</span> last <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
  head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head
  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token keyword">return</span> last
<span class="token punctuation">}</span>
</code></pre></div><p><strong>对于递归算法，最重要的就是明确递归函数的定义</strong>。</p><p>对于 <code>reverse</code> 函数来说，定义是这样的：输入一个节点 <code>head</code>，将以 <code>head</code> 为起点的链表反转，并返回反转之后的头结点。</p><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/递归反转链表.svg" alt=""></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>确定了递归函数的定义，在思考时切记不要深入到递归过程里面去，否则脑子很快就乱了。</p></div><p>在写 <code>newHead = reverse(head.next)</code> 这行时，只要相信 <code>newHead</code> 就是除 <code>head</code> 以外的链表反转后的头结点就行了，其余的递归会帮你完成。</p><h3 id="反转前-n-个" tabindex="-1"><a class="header-anchor" href="#反转前-n-个"><span>反转前 n 个</span></a></h3><p>和反转整个链表类似，不过我们需要额外一个变量表示反转多少个节点。</p><p>递归函数定义：<code>reverseN(head, n)</code> 将以 head 开始的链表的前 n 个节点反转，返回反转后的头结点。</p><p>为了反转前 n 个节点后还能连接上剩余节点，需要 successor 变量保存，当 <code>n === 1</code> 时表示到了需要反转的尾部，此时下一个节点就是 successor。</p><p>以反转前 3 个节点为例，过程如下图：</p><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/递归反转链表前n个.svg" alt=""></p><p>代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">function</span> <span class="token function">reverseN</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successor <span class="token operator">=</span> head<span class="token punctuation">.</span>next
    <span class="token keyword">return</span> head <span class="token comment">// 只剩一个节点时，不用反转</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> last <span class="token operator">=</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head
  head<span class="token punctuation">.</span>next <span class="token operator">=</span> successor

  <span class="token keyword">return</span> last
<span class="token punctuation">}</span>
</code></pre></div><h3 id="反转链表区间-92" tabindex="-1"><a class="header-anchor" href="#反转链表区间-92"><span>反转链表区间 ( 92 )</span></a></h3><p>给定一个区间 [m, n]，索引从 1 开始，反转这个区间中的链表。</p><ul><li><p>当 <code>m === 1</code>，和前面的“反转前 n 个节点”问题一样</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>当 <code>m !== 1</code></p><p>我们把 head 摘出来看，剩余的链表长度就会减一，相当于在剩余链表中找到 [m - 1, n - 1] 区间来反转，持续递归，直到 <code>m === 1</code>，这就回到了上一种情况，调用 <code>reverseN</code> 进行反转。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 递归基</span>
    <span class="token keyword">return</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> head
<span class="token punctuation">}</span>
</code></pre></div></li></ul><h3 id="k-个一组反转-25" tabindex="-1"><a class="header-anchor" href="#k-个一组反转-25"><span>K 个一组反转 ( 25 )</span></a></h3><p>运用递归的思想，我们定义递归函数 <code>reverseKGroup(head, k)</code>：将从 head 节点开始的链表以 k 个为一组反转。</p><p>以 <code>k === 3</code> 为例。一开始，我们调用 <code>reverseN(head, 3)</code> 先将前 3 个节点，也就是第一组反转完成；然后将第 4 个节点作为头结点递归调用 <code>reverseKGroup(head.next, 3)</code>，也就是下图中的 <code>successor</code>。</p><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/递归反转链表前n个.svg" alt=""></p><p>需要注意的是，按题目意思，剩余不满一组的节点是不用反转的。因此， <code>reverseKGroup</code> 需要计算剩余节点数量，如果小于 k 则直接返回。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 一个或零个节点直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> head
  <span class="token punctuation">}</span>

  <span class="token comment">// 计算当前链表长度是否大于等于 k</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> head
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 循环 k 次前遇到 null，说明链表长度小于 k</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> head
    <span class="token punctuation">}</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> last <span class="token operator">=</span> <span class="token function">reverseN</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 反转前 k 个</span>
  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
  <span class="token keyword">return</span> last
<span class="token punctuation">}</span>
</code></pre></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>相比迭代，递归要难以理解。递归的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。只要确信递归的定义是正确的，剩下的递归会帮你完成。</p><p>反转链表前 n 个节点函数 <code>reverseN</code> 函数很有用，他在“反转链表区间”和“ k 个一组反转”两个问题中都有用到。</p><h2 id="回文链表" tabindex="-1"><a class="header-anchor" href="#回文链表"><span>回文链表</span></a></h2><p>关于回文，前面数组双指针中有提到。回文问题有两类：寻找回文子串、判断回文串。</p><p>寻找回文子串的核心思想是从中心向两端扩展；判断回文串的核心思想是双指针从两端向中间靠拢。</p><h3 id="判断回文单链表-234" tabindex="-1"><a class="header-anchor" href="#判断回文单链表-234"><span>判断回文单链表 ( 234 )</span></a></h3><p>单链表是无法直接反向遍历的，为此我们有几种解决办法。比如：</p><ul><li>反转：将链表反转并另存为一条新链表，然后对比两条链表</li><li>栈：用栈将顺序遍历的结果存起来，遍历栈就是逆序遍历链表</li><li>递归栈：利用递归栈代替栈</li></ul><p>这里介绍用递归栈的做法。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
    <span class="token comment">// 后序遍历</span>
    res <span class="token operator">=</span> res <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
  <span class="token keyword">return</span> <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>无论是反转另存还是栈、递归，都需要额外的空间。</p><p>其实我们可以反转后一半的节点，然后模拟左右指针来判断回文。</p><h3 id="反转后半节点判断回文链表" tabindex="-1"><a class="header-anchor" href="#反转后半节点判断回文链表"><span>反转后半节点判断回文链表</span></a></h3><p>要反转后半部分节点，第一步需要找到链表的中点。</p><p>找链表中点的问题上一节介绍过了，就是快慢指针。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slow
<span class="token punctuation">}</span>
</code></pre></div><p>如果 fast 指针指向 null，说明链表长度为奇数，则 slow 需要前进一步，因为奇数的回文是不需要判断中点本身的。</p><p>比如下图中链表一的 slow 指向 3，而我们需要反转的是 3 节点后面的 2 和 1。</p><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/回文链表.svg" alt=""></p><p>反转完节点后，链表变成了下图的样子。</p><p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/回文链表2.svg" alt=""></p><p>整理一下过程：</p><ul><li>找到后半节点的起点</li><li>反转后半节点</li><li>双指针判断回文</li></ul><p>代码如下：</p><p>找到后半节点的起始节点（奇数链表不包括中点）：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">halfStart</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> fast <span class="token operator">===</span> <span class="token keyword">null</span>
    <span class="token operator">?</span> slow
  	<span class="token operator">:</span> slow<span class="token punctuation">.</span>next <span class="token comment">// 奇数链表不包括中点</span>
<span class="token punctuation">}</span>
</code></pre></div><p>反转链表：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev
    prev <span class="token operator">=</span> cur
    cur <span class="token operator">=</span> next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> prev
<span class="token punctuation">}</span>
</code></pre></div><p>综合得代码：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> head<span class="token punctuation">,</span>
      right <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token function">halfStart</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 反转后半节点</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    left <span class="token operator">=</span> left<span class="token punctuation">.</span>next
    right <span class="token operator">=</span> right<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div>`,62),o=[e];function c(l,r){return a(),s("div",null,o)}const i=n(p,[["render",c],["__file","2.1.反转链表.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/2.1.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html","title":"反转链表","lang":"zh-CN","frontmatter":{"description":"反转链表 迭代反转 ( 206 ) 给定一个链表的头结点，返回反转整个链表后的头结点。 如果用迭代方式反转，代码大概如下： 相比于迭代，递归操作链表并不高效，因为递归需要 O(n) 的空间复杂度。我们着重了解链表天然的递归特性即可。 递归反转 ( 206 ) 如果用递归实现反转链表，代码如下： 对于递归算法，最重要的就是明确递归函数的定义。 对于 re...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/2.1.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"反转链表"}],["meta",{"property":"og:description","content":"反转链表 迭代反转 ( 206 ) 给定一个链表的头结点，返回反转整个链表后的头结点。 如果用迭代方式反转，代码大概如下： 相比于迭代，递归操作链表并不高效，因为递归需要 O(n) 的空间复杂度。我们着重了解链表天然的递归特性即可。 递归反转 ( 206 ) 如果用递归实现反转链表，代码如下： 对于递归算法，最重要的就是明确递归函数的定义。 对于 re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"反转链表\\",\\"image\\":[\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.svg\\",\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA.svg\\",\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%89%8Dn%E4%B8%AA.svg\\",\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.svg\\",\\"https://raw.githubusercontent.com/yamsfeer/pic-bed/master/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A82.svg\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"迭代反转 ( 206 )","slug":"迭代反转-206","link":"#迭代反转-206","children":[]},{"level":2,"title":"递归反转 ( 206 )","slug":"递归反转-206","link":"#递归反转-206","children":[{"level":3,"title":"反转前 n 个","slug":"反转前-n-个","link":"#反转前-n-个","children":[]},{"level":3,"title":"反转链表区间 ( 92 )","slug":"反转链表区间-92","link":"#反转链表区间-92","children":[]},{"level":3,"title":"K 个一组反转 ( 25 )","slug":"k-个一组反转-25","link":"#k-个一组反转-25","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"回文链表","slug":"回文链表","link":"#回文链表","children":[{"level":3,"title":"判断回文单链表 ( 234 )","slug":"判断回文单链表-234","link":"#判断回文单链表-234","children":[]},{"level":3,"title":"反转后半节点判断回文链表","slug":"反转后半节点判断回文链表","link":"#反转后半节点判断回文链表","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":5.7,"words":1710},"filePathRelative":"编程/leetcode/2.1.反转链表.md","localizedDate":"2024年4月12日","autoDesc":true}');export{i as comp,d as data};
