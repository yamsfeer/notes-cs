import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-BzW9chhs.js";const p={},o=t(`<h1 id="二叉搜索树构造" tabindex="-1"><a class="header-anchor" href="#二叉搜索树构造"><span>二叉搜索树构造</span></a></h1><h2 id="不同的二叉树-96" tabindex="-1"><a class="header-anchor" href="#不同的二叉树-96"><span>不同的二叉树 ( 96 )</span></a></h2><p>求由 <code>[1, n]</code> 这些数字构成的不同结构的 BST 有多少种。比如 <code>n = 3</code> 时有 5 种结构。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5uml7ykt1j20p1066dg6.jpg" style="zoom:50%;"><p>以 <code>n = 5</code> 为例，<code>[1,2,3,4,5]</code> 这 5 个数中，任一个数都可以作为根节点。</p><p>当取 3 作为根节点时，其左子树必然由 <code>1,2</code> 构成，右子树必然由 <code>4,5</code> 构成，又可以递归计算。</p><p>我们可以用数组索引组成区间。代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token parameter">lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lo <span class="token operator">&gt;</span> hi<span class="token punctuation">)</span> <span class="token comment">// base case</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token comment">// 注意返回1</span>

  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

    res <span class="token operator">+=</span> left <span class="token operator">*</span> right
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意，当 <code>lo &gt; hi</code> 时，<code>[lo, hi]</code> 是个空区间，对应节点是 <code>null</code>，此时应该返回 1 而不是 0，否则 <code>left * right</code> 就变成 0 了。</p><p>以上算法可以解决问题，但时间复杂度太高。原因在于重复计算太多，我们需要一个备忘录消除重叠子问题。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token parameter">lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 查备忘录</span>
      <span class="token keyword">return</span> memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算 res ...</span>
    memo<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token comment">// 存入备忘录</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="构造不同的二叉树-95" tabindex="-1"><a class="header-anchor" href="#构造不同的二叉树-95"><span>构造不同的二叉树 ( 95 )</span></a></h2><p>构造由 <code>[1, n]</code> 这些数字构成的不同结构的 BST。</p><p>这题和上一题思路是一样的，不同的地方是要把这些树都构造出来。</p><ul><li>穷举所有可能的 root 节点</li><li>递归构造所有可能左右子树</li><li>将 root 和可能的左右子树组合起来</li></ul><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lo <span class="token operator">&gt;</span> hi<span class="token punctuation">)</span> <span class="token comment">// base case</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span> <span class="token comment">// 注意 build 函数返回的是数组</span>

  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> rootVal <span class="token operator">=</span> i
    <span class="token keyword">const</span> lefts <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 可能的左子树的数组</span>
    <span class="token keyword">const</span> rights <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span> <span class="token comment">// 可能的右子树的数组</span>

    <span class="token comment">// root 和 lefts、rights 组合</span>
		res <span class="token operator">=</span> <span class="token function">combine</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">,</span> lefts<span class="token punctuation">,</span> rights<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个算法和上一题整体思路是一致的，只是构造所有可能结构的子树，返回的是数组，然后 root 节点要和这些子树组合起来，组合这一步需要双重循环。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 将 root 和可能的左右子树组合起来</span>
<span class="token keyword">function</span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token parameter">rootVal<span class="token punctuation">,</span> lefts<span class="token punctuation">,</span> rights</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> trees <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> left <span class="token keyword">of</span> lefts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> right <span class="token keyword">of</span> rights<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
      root<span class="token punctuation">.</span>left <span class="token operator">=</span> left
      root<span class="token punctuation">.</span>right <span class="token operator">=</span> right
      trees<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> trees
<span class="token punctuation">}</span>
</code></pre></div>`,18),e=[o];function c(l,u){return s(),a("div",null,e)}const r=n(p,[["render",c],["__file","4.1.二叉搜索树构造.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/4.1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9E%84%E9%80%A0.html","title":"二叉搜索树构造","lang":"zh-CN","frontmatter":{"description":"二叉搜索树构造 不同的二叉树 ( 96 ) 求由 [1, n] 这些数字构成的不同结构的 BST 有多少种。比如 n = 3 时有 5 种结构。 以 n = 5 为例，[1,2,3,4,5] 这 5 个数中，任一个数都可以作为根节点。 当取 3 作为根节点时，其左子树必然由 1,2 构成，右子树必然由 4,5 构成，又可以递归计算。 我们可以用数组索引...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/4.1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9E%84%E9%80%A0.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"二叉搜索树构造"}],["meta",{"property":"og:description","content":"二叉搜索树构造 不同的二叉树 ( 96 ) 求由 [1, n] 这些数字构成的不同结构的 BST 有多少种。比如 n = 3 时有 5 种结构。 以 n = 5 为例，[1,2,3,4,5] 这 5 个数中，任一个数都可以作为根节点。 当取 3 作为根节点时，其左子树必然由 1,2 构成，右子树必然由 4,5 构成，又可以递归计算。 我们可以用数组索引..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉搜索树构造\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"不同的二叉树 ( 96 )","slug":"不同的二叉树-96","link":"#不同的二叉树-96","children":[]},{"level":2,"title":"构造不同的二叉树 ( 95 )","slug":"构造不同的二叉树-95","link":"#构造不同的二叉树-95","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":2.02,"words":607},"filePathRelative":"编程/leetcode/4.1.二叉搜索树构造.md","localizedDate":"2024年4月12日","autoDesc":true}');export{r as comp,d as data};
