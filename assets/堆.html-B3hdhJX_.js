import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as p}from"./app-BzW9chhs.js";const t={},o=p(`<h1 id="堆-heap" tabindex="-1"><a class="header-anchor" href="#堆-heap"><span>堆 ( heap )</span></a></h1><p>堆可分为最大堆，最小堆。</p><ul><li>最大堆：所有子树的根节点不小于左右孩子</li><li>最小堆：所有子树的根节点不大于左右孩子</li></ul><p>堆和二叉搜索树的区别在于：堆的每个节点作为根节点与左右孩子比较，二叉搜索树则是每个节点作为根节点与左右子树的比较。</p><p>最大最小堆都是完全二叉树，因此可用数组来存储堆。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>      0
    /   \\
   1     2
  / \\   / \\
 3   4  5
</code></pre></div><p>在数组中的存储刚好是 012345，且有:</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">parent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
<span class="token function">lchild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token function">rchild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
</code></pre></div><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p>我们用一个数组存储堆节点，从 0 索引开始存储。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MaxHeap</span> <span class="token punctuation">{</span>
  data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>length
  <span class="token punctuation">}</span>
  <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 先推入尾结点，然后 siftUp</span>
  <span class="token punctuation">}</span>
  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 将最后一个节点替换根节点，然后 siftDown</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> head
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里有两个重要操作 sift up 和 sift down，用于维护堆和合法性。</p><h3 id="siftup" tabindex="-1"><a class="header-anchor" href="#siftup"><span>siftUp</span></a></h3><p>以最大堆为例，当将一个新元素 E 插入数组末尾时，可能会破坏堆序性，但这个新元素只会影响它所在的子树，</p><ul><li><p>如果 E &gt; parent(E)，则与父节点交换</p></li><li><p>上一步交换后可能仍不满足堆序性，则需要逐层向上交换直到根节点，最终再次满足堆特性。</p></li></ul><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>
  <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> parent <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
      i <span class="token operator">=</span> parent
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="siftdown" tabindex="-1"><a class="header-anchor" href="#siftdown"><span>siftDown</span></a></h3><p>以最大堆为例，在删除最大元delMax操作中，</p><ul><li><p>将数组最后一个元素 E 和堆顶元素 Max 交换，删除 Max</p></li><li><p>将交换后的堆顶元素 E 与它的左右孩子比较，并将 E 与左右孩子中的较大者交换，循环直至 E 为叶子节点</p></li></ul><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>
  <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data
    <span class="token keyword">const</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lchild <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token keyword">const</span> rchild <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>lchild <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左孩子越界，右孩子肯定越界</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">const</span> maxChild <span class="token operator">=</span> rchild <span class="token operator">&gt;=</span> size <span class="token comment">// 只有左孩子</span>
        <span class="token operator">?</span> data<span class="token punctuation">[</span>lChild<span class="token punctuation">]</span>
        <span class="token operator">:</span> data<span class="token punctuation">[</span>lchild<span class="token punctuation">]</span> <span class="token operator">&gt;</span> data<span class="token punctuation">[</span>rchild<span class="token punctuation">]</span> <span class="token comment">// 有左右孩子。找出较大孩子</span>
          <span class="token operator">?</span> lchild
          <span class="token operator">:</span> rchild

      <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>maxChild<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点小于两个孩子节点</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxChild<span class="token punctuation">)</span>
        i <span class="token operator">=</span> maxChild
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点大于两个孩子节点，siftDown 结束</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="heapify" tabindex="-1"><a class="header-anchor" href="#heapify"><span>heapify</span></a></h3><p>heapify 就是将一个已存在的数组转化成堆。</p><p>简单做法是从左到右循环，针对每个节点做一次 add 操作，时间复杂度是 O(nlogn)。</p><p>事实上，我们可以将所有叶子节点都视为已经符合堆性质，然后从第一个非叶子结点开始，从后往前直到根节点做 sift down 操作即可。其中，第一个非叶子节点就是最后一个节点的父节点。</p><p>这称为 Floyd 算法，时间复杂度为 O(n)，复杂度的计算过程比较复杂，这里不介绍。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>
   <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> last <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">const</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 从第一个非叶子节点开始</span>
    
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">siftDown</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="replace" tabindex="-1"><a class="header-anchor" href="#replace"><span>replace</span></a></h3><p>replace 操作就是取出当前堆顶元素，然后替换成另一个元素 E，并且要保持堆性质。</p><p>简单的做法是先 pop 操作，然后 add(E)，这样需要两次 logn 的时间复杂度。</p><p>我们可以直接将堆顶元素替换成 E，然后进行 sift down，这样只需一次 logn 时间复杂度的操作。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>
  <span class="token function">replace</span><span class="token punctuation">(</span><span class="token parameter">ele</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ele
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> head
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="优先队列-priority-queue" tabindex="-1"><a class="header-anchor" href="#优先队列-priority-queue"><span>优先队列 ( priority queue )</span></a></h2><p>用堆来实现优先队列是非常容易的，对于最大堆来说，节点的值越大，其优先级越高，同理，最小堆节点的值越小，其优先级越高。</p><p>对于怎样才算优先级高，可以用一个 compare 函数表达，我们要改动的是将 sift down 和 sift up 过程中关于比较节点大小的部分用 compare 函数替代。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">compare</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>compare <span class="token operator">=</span> compare
  <span class="token punctuation">}</span>
  <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> parent <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前节点优先级高于父亲节点</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>
        i <span class="token operator">=</span> parent
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lchild <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token keyword">const</span> rchild <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>lchild <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左孩子越界，右孩子肯定越界</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      
      <span class="token keyword">const</span> maxChild <span class="token operator">=</span> rchild <span class="token operator">&gt;=</span> size <span class="token comment">// 只有左孩子</span>
        <span class="token operator">?</span> lchild
        <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>lchild<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>rchild<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 左孩子优先级高</span>
          <span class="token operator">?</span> lchild
          <span class="token operator">:</span> rchild
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>maxChild<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前节点优先级高于左右孩子</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> maxChild<span class="token punctuation">)</span>
        i <span class="token operator">=</span> maxChild
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当使用这个优先级队列时，需要传入定义优先级高的函数：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token comment">// 值越大优先级越高，等同于最大堆</span>
</code></pre></div><h3 id="优先队列的应用" tabindex="-1"><a class="header-anchor" href="#优先队列的应用"><span>优先队列的应用</span></a></h3><p>优先队列的一个经典问题是：在 n 个元素中选出前 m 个元素。比如，在 100,000 个数字中选出前 100 个数字。</p><p>如果使用排序，时间复杂度为 nlogn，如果使用优先队列，时间复杂度为 nlogm。</p><p>我们可以用一个最小堆维护前 m 个节点，其余元素依次与堆顶元素比较，如果堆顶元素更大，则进行 replace。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">headM</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> b <span class="token operator">-</span> a<span class="token punctuation">)</span> <span class="token comment">// 注意我们需要的是最小堆</span>
  qp<span class="token punctuation">.</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 只维护 m 个元素</span>

  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> item <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      pq<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 堆中就是前 m 个最小元素</span>
  <span class="token keyword">return</span> pq<span class="token punctuation">.</span>data
<span class="token punctuation">}</span>
</code></pre></div><h3 id="leetcode-347-题-前-k-个高频元素" tabindex="-1"><a class="header-anchor" href="#leetcode-347-题-前-k-个高频元素"><span>leetcode 347 题：前 K 个高频元素</span></a></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。</p><p>这就是上面提到的“在 m 个元素中选出前 m 个元素”的题目，只是我们需要先统计一次 nums 中元素的频次。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 统计频次</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> num <span class="token keyword">of</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span> map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PQ</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>count <span class="token operator">-</span> b<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 最小堆，频次低的在堆顶</span>

  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 用于判定前 k 个</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> item
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">++</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 先将 k 个元素加入优先队列</span>
      pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">{</span> num<span class="token punctuation">,</span> count <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 当前频次比堆中最小频次高即可替换</span>
        pq<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">{</span> num<span class="token punctuation">,</span> count <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> pq<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">node</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 堆中元素即是前 k 频次的</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先，在这个问题中，频次高表示优先级高，但是我们使用的是最小堆，因为我们需要堆元素中，频次最低的在堆顶，后续节点只需频次高于堆顶元素即可入堆。</p><h2 id="堆排序-heap-sort" tabindex="-1"><a class="header-anchor" href="#堆排序-heap-sort"><span>堆排序 ( heap sort )</span></a></h2><p>使用堆进行排序，只需要先对目标序列进行 heapify 操作，使其成为最大堆或最小堆，然后依次取出堆顶元素直至堆为空。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// heapify</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不停取出最大值</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p>前面提到过，heapify 操作的复杂度是 O(n)，n 次取出堆顶元素的时间复杂度是 O(nlogn)。</p>`,51),e=[o];function c(l,u){return s(),a("div",null,e)}const r=n(t,[["render",c],["__file","堆.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%A0%86.html","title":"堆 ( heap )","lang":"zh-CN","frontmatter":{"description":"堆 ( heap ) 堆可分为最大堆，最小堆。 最大堆：所有子树的根节点不小于左右孩子 最小堆：所有子树的根节点不大于左右孩子 堆和二叉搜索树的区别在于：堆的每个节点作为根节点与左右孩子比较，二叉搜索树则是每个节点作为根节点与左右子树的比较。 最大最小堆都是完全二叉树，因此可用数组来存储堆。 在数组中的存储刚好是 012345，且有: 实现 我们用一个...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%A0%86.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"堆 ( heap )"}],["meta",{"property":"og:description","content":"堆 ( heap ) 堆可分为最大堆，最小堆。 最大堆：所有子树的根节点不小于左右孩子 最小堆：所有子树的根节点不大于左右孩子 堆和二叉搜索树的区别在于：堆的每个节点作为根节点与左右孩子比较，二叉搜索树则是每个节点作为根节点与左右子树的比较。 最大最小堆都是完全二叉树，因此可用数组来存储堆。 在数组中的存储刚好是 012345，且有: 实现 我们用一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆 ( heap )\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[{"level":3,"title":"siftUp","slug":"siftup","link":"#siftup","children":[]},{"level":3,"title":"siftDown","slug":"siftdown","link":"#siftdown","children":[]},{"level":3,"title":"heapify","slug":"heapify","link":"#heapify","children":[]},{"level":3,"title":"replace","slug":"replace","link":"#replace","children":[]}]},{"level":2,"title":"优先队列 ( priority queue )","slug":"优先队列-priority-queue","link":"#优先队列-priority-queue","children":[{"level":3,"title":"优先队列的应用","slug":"优先队列的应用","link":"#优先队列的应用","children":[]},{"level":3,"title":"leetcode 347 题：前 K 个高频元素","slug":"leetcode-347-题-前-k-个高频元素","link":"#leetcode-347-题-前-k-个高频元素","children":[]}]},{"level":2,"title":"堆排序 ( heap sort )","slug":"堆排序-heap-sort","link":"#堆排序-heap-sort","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":5.91,"words":1773},"filePathRelative":"编程/数据结构算法/堆.md","localizedDate":"2024年4月12日","autoDesc":true}');export{r as comp,d as data};
