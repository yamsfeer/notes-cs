import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,b as d}from"./app-BzW9chhs.js";const l={},r=d(`<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h1><h2 id="重定位" tabindex="-1"><a class="header-anchor" href="#重定位"><span>重定位</span></a></h2><p>编译后的代码中的地址是逻辑地址，它需要和寄存器中的基地址结合，获取真正的地址。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>地址 = 基地址 + 逻辑地址
</code></pre></div><p>这步操作可以在编译时、载入时、运行时完成。</p><p>注意：基地址存放在寄存器中，它会随着进程调度切换和恢复。</p><p>一个进程自身的基地址是存放在 PCB 中，进程切换时，会将 PCB 中的基地址放入寄存器。</p><h3 id="编译时" tabindex="-1"><a class="header-anchor" href="#编译时"><span>编译时</span></a></h3><h3 id="载入时" tabindex="-1"><a class="header-anchor" href="#载入时"><span>载入时</span></a></h3><h3 id="运行时" tabindex="-1"><a class="header-anchor" href="#运行时"><span>运行时</span></a></h3><h2 id="分段" tabindex="-1"><a class="header-anchor" href="#分段"><span>分段</span></a></h2><p>一个进程的内存是分段的</p><ul><li>主程序 main，特点：只读</li><li>变量集</li><li>函数库</li><li>动态数组</li><li>栈</li></ul><p>程序中的逻辑地址实际上是根据分段地址偏移的。</p><p>因此，具体指令中访问数据的方式是 段号，段内偏移</p><div class="language-assembly" data-ext="assembly" data-title="assembly"><pre class="language-assembly"><code>mov [es:bx], ax
</code></pre></div><h3 id="进程段表" tabindex="-1"><a class="header-anchor" href="#进程段表"><span>进程段表</span></a></h3><p>每个进程都有一个进程段表，记录段的基址和长度。</p><table><thead><tr><th>段号</th><th>基址</th><th>长度</th><th>保护</th></tr></thead><tbody><tr><td>0</td><td>180K</td><td>150K</td><td>R</td></tr><tr><td>1</td><td>360K</td><td>60K</td><td>R/W</td></tr><tr><td>2</td><td>70K</td><td>110K</td><td>R/W</td></tr><tr><td>3</td><td>460K</td><td>40K</td><td>R</td></tr></tbody></table><p>操作系统的进程段表就是 GDT 表，进程段表是 LDT。</p><p>LDT 本身属于进程的信息，因此存放在进程的</p><p>PCB 中。存放当前进程的 LDT 表的位置的寄存器是 ldtr 寄存器。</p>`,22),i=[r];function n(s,o){return e(),a("div",null,i)}const h=t(l,[["render",n],["__file","3.内存管理.html.vue"]]),m=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{"description":"内存管理 重定位 编译后的代码中的地址是逻辑地址，它需要和寄存器中的基地址结合，获取真正的地址。 这步操作可以在编译时、载入时、运行时完成。 注意：基地址存放在寄存器中，它会随着进程调度切换和恢复。 一个进程自身的基地址是存放在 PCB 中，进程切换时，会将 PCB 中的基地址放入寄存器。 编译时 载入时 运行时 分段 一个进程的内存是分段的 主程序 ...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"内存管理 重定位 编译后的代码中的地址是逻辑地址，它需要和寄存器中的基地址结合，获取真正的地址。 这步操作可以在编译时、载入时、运行时完成。 注意：基地址存放在寄存器中，它会随着进程调度切换和恢复。 一个进程自身的基地址是存放在 PCB 中，进程切换时，会将 PCB 中的基地址放入寄存器。 编译时 载入时 运行时 分段 一个进程的内存是分段的 主程序 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"重定位","slug":"重定位","link":"#重定位","children":[{"level":3,"title":"编译时","slug":"编译时","link":"#编译时","children":[]},{"level":3,"title":"载入时","slug":"载入时","link":"#载入时","children":[]},{"level":3,"title":"运行时","slug":"运行时","link":"#运行时","children":[]}]},{"level":2,"title":"分段","slug":"分段","link":"#分段","children":[{"level":3,"title":"进程段表","slug":"进程段表","link":"#进程段表","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":1.09,"words":326},"filePathRelative":"计算机基础/操作系统/3.内存管理.md","localizedDate":"2024年4月12日","autoDesc":true}');export{h as comp,m as data};
