import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as p,a as s,b as n,d as t}from"./app-BzW9chhs.js";const o={},l=n(`<h1 id="动态规划-dynamic-programming" tabindex="-1"><a class="header-anchor" href="#动态规划-dynamic-programming"><span>动态规划 ( Dynamic Programming )</span></a></h1><p>动态规划问题的一般形式是<strong>求最值</strong>。解决动态规划问题的核心是<strong>穷举</strong>，穷举所有可行解，然后在其中找出最值。</p><p>动态规划三要素：最优子结构、状态转移方程、重叠子问题。</p><ul><li>最优子结构：子问题的最值能否推出原问题的最值，这是动态规划的前提</li><li>状态转移方程：只有列出正确的状态转移方程，才能正确地穷举，这是核心步骤</li><li>重叠子问题：重叠子问题使得穷举的效率很低，可以使用 DP table 来避免不必要的计算</li></ul><p>下面通过两个问题详解动态规划的基本原理。</p><h2 id="斐波那契数列-509" tabindex="-1"><a class="header-anchor" href="#斐波那契数列-509"><span>斐波那契数列 ( 509 )</span></a></h2><p>斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。求数列任一项。</p><h3 id="暴力递归" tabindex="-1"><a class="header-anchor" href="#暴力递归"><span>暴力递归</span></a></h3><p>根据斐波那契数列的定义，我们很容易写出递归解法。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> n
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当 <code>n = 20</code> 时，<code>fib(20)</code> 的递归树如下图：</p><p><em>（ 凡是递归的问题，最好画出递归树，这对分析算法复杂度，寻找算法低效的原因有巨大帮助 ）</em></p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5vmkwgh74j20zk0k0mye.jpg" style="zoom:40%;">`,13),c=s("p",null,[t("整个算法的时间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mn",null,"2"),s("mi",null,"n")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(2^n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6644em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])])])])])]),s("span",{class:"mclose"},")")])])]),t("。")],-1),i=n(`<p>很明显，这个算法存在大量重复计算，比如 <code>f(19)=f(18)+f(17)</code>，而 <code>f(18)=f(17)+f(16)</code>，<code>f(17)</code> 计算了两次，这种重复的节点大量存在于递归树中。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。</p><h3 id="带备忘录的递归" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归"><span>带备忘录的递归</span></a></h3><p>为了解决重复计算的问题，我们可以用备忘录将已计算过的情况存起来，以空间换时间。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 备忘录</span>

<span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n <span class="token comment">// base case</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token comment">// 查备忘录</span>

  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 存备忘录</span>
<span class="token punctuation">}</span>
</code></pre></div><p>带备忘录的递归算法，实际上就是通过对递归树进行<strong>剪枝</strong>，从而极大减少了子问题。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5w5rg2w7nj20zk0k0tb0.jpg" style="zoom:40%;"><p>改进后算法的时间复杂度为 O(n)，因为子问题就是 <code>f(1),f(2),...,f(20)</code>，和问题规模 n 成正比。</p><h4 id="自顶向下和自底向上" tabindex="-1"><a class="header-anchor" href="#自顶向下和自底向上"><span>自顶向下和自底向上</span></a></h4><p>实际上，这种解法是<strong>自顶向下</strong>进行<strong>递归</strong>求解。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5w5rlp4j1j20zk0k0mzf.jpg" style="zoom:35%;"><p>而常见的动态规划代码是<strong>自底向上</strong>进行<strong>递推</strong>求解。</p><ul><li>自顶向下：从规模较大的原问题，向下逐渐减小规模，递归树从根节点延伸到叶子结点</li><li>自底向上：从最小规模的 base case 逐渐往上递推，直到推出想要的答案</li></ul><p>动态规划一般不用递归，而是循环迭代计算。</p><p>下面就来介绍用自底向上的递推解决斐波那契数列问题。</p><h3 id="dp-table-递推" tabindex="-1"><a class="header-anchor" href="#dp-table-递推"><span>dp table 递推</span></a></h3><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个算法和前面递归剪枝的算法差不多，只是从底向上算而已，效率也一样。</p><p>这里引出<strong>状态转移方程</strong>的概念，对于斐波那契数列来说，状态转移方程如下：</p>`,19),r=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"{"),s("mtable",{rowspacing:"0.36em",columnalign:"left left",columnspacing:"1em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mn",null,"1")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("mn",null,"1"),s("mo",{separator:"true"},","),s("mn",null,"2")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mi",null,"f"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mn",null,"2"),s("mo",{stretchy:"false"},")")])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"n"),s("mo",null,">"),s("mn",null,"2")])])])])])])]),s("annotation",{encoding:"application/x-tex"}," f(n)= \\begin{cases} 1 & n=1,2\\\\ f(n-1)+f(n-2) & n > 2 \\end{cases} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3em","vertical-align":"-1.25em"}}),s("span",{class:"minner"},[s("span",{class:"mopen delimcenter",style:{top:"0em"}},[s("span",{class:"delimsizing size4"},"{")]),s("span",{class:"mord"},[s("span",{class:"mtable"},[s("span",{class:"col-align-l"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.69em"}},[s("span",{style:{top:"-3.69em"}},[s("span",{class:"pstrut",style:{height:"3.008em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"1")])]),s("span",{style:{top:"-2.25em"}},[s("span",{class:"pstrut",style:{height:"3.008em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mclose"},")")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.19em"}},[s("span")])])])]),s("span",{class:"arraycolsep",style:{width:"1em"}}),s("span",{class:"col-align-l"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.69em"}},[s("span",{style:{top:"-3.69em"}},[s("span",{class:"pstrut",style:{height:"3.008em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},"2")])]),s("span",{style:{top:"-2.25em"}},[s("span",{class:"pstrut",style:{height:"3.008em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.19em"}},[s("span")])])])])])]),s("span",{class:"mclose nulldelimiter"})])])])])])],-1),u=n(`<p>在这个例子中，n 就是状态，n 的状态由状态 <code>n-1</code> 和 <code>n-2</code> 转移 ( 相加 ) 而来，这就叫状态转移。</p><p>前面的代码中，如 <code>f(n - 1) + f(n - 2)</code> 和 <code>dp[i] = dp[i - 1] + dp[i - 2]</code> 以及对备忘录或 dp table 的初始化操作，都是围绕这个方程的不同表现形式。</p><p>根据状态转移方程，当前状态只和前两个状态有关，所以 dp table 不需要存储所有的状态，只要存储前两个状态就行了。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> n

  <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> pprev <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 前两个状态</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> pprev <span class="token comment">// 相当于 dp[i] = dp[i - 1] + dp[i - 2]</span>
    pprev <span class="token operator">=</span> prev
    prev <span class="token operator">=</span> sum
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> prev
<span class="token punctuation">}</span>
</code></pre></div><p>斐波那契数列严格来说不算动态规划问题，因为没有涉及求最值，以上旨在说明重叠子问题及其消除方法。</p><p>上面介绍了状态转移方程和重叠子问题，下面通过凑零钱问题说明什么是“最优子结构”。</p><h2 id="凑零钱问题-322" tabindex="-1"><a class="header-anchor" href="#凑零钱问题-322"><span>凑零钱问题 ( 322 )</span></a></h2><p>数组 coins 表示不同面额的硬币，amount 表示总金额，计算凑出 amount 所需的<strong>最少的硬币个数</strong> 。</p><p>每种硬币的数量是无限的。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
</code></pre></div><h3 id="暴力递归-1" tabindex="-1"><a class="header-anchor" href="#暴力递归-1"><span>暴力递归</span></a></h3><p>凑零钱问题时符合最优子结构的。以 <code>amount = 11</code> 为例，如果已知凑出 <code>amount = 10, 9, 6</code> 的最少硬币数 ( 子问题 )，只需再选一枚面值为 <code>1, 2, 5</code> 的硬币，其中硬币数最少的就是答案。由于硬币数量是没有限制的，子问题互相独立，所以说它是符合最优子结构。</p><p>既然知道了这是动态规划问题，就要思考列出状态转移方程：</p><ol><li><p>确定 state，即原问题和子问题中会变化的变量</p><p>硬币的数量无限且面额固定，只有 amount 会不断地向 base case 靠近，所以 amount 就是 state。</p></li><li><p>明确 dp 函数的定义</p><p>dp 函数的参数一般是 state，返回值是要求计算的量。即 <code>dp(amount)</code> 表示凑出 amount 所需的最少硬币数量。</p></li><li><p>确定 choice，即导致 state 变化的行为</p><p>amount 会变化是因为你在选择硬币，每选择一枚硬币，就相当于减少了目标金额。因此，硬币的面额就是你的 choice。</p></li><li><p>确定 base case</p><p><code>amount = 0</code> 时算法返回 0，因为不需要任何硬币就已经凑出目标金额。</p></li></ol><p>综合以上，定义 dp 函数：输入目标金额 amount，返回凑出 amount 所需的最少硬币数量。</p><p>算法伪码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token parameter">amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span>
    res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>根据伪码，加上 base case 即可写出最终算法 ( 自顶向下递归 ) 。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>

  <span class="token keyword">let</span> res <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sub <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sub <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span>
    res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res <span class="token operator">===</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码的数学形式就是状态转移方程：</p>`,20),m={class:"katex-block"},k={class:"katex-display"},d={class:"katex"},h=s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mi",null,"d"),s("mi",null,"p"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"{"),s("mtable",{rowspacing:"0.36em",columnalign:"left left",columnspacing:"1em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mn",null,"0")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"n"),s("mo",null,"="),s("mn",null,"0")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mo",null,"−"),s("mn",null,"1")])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"n"),s("mo",null,"<"),s("mn",null,"0")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"d"),s("mi",null,"p"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"−"),s("mi",null,"c"),s("mi",null,"o"),s("mi",null,"i"),s("mi",null,"n"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mi",null,"n"),s("mo",null,">"),s("mn",null,"0")])])])])])])]),s("annotation",{encoding:"application/x-tex"}," dp(n)= \\begin{cases} 0 & n = 0\\\\ -1 & n < 0\\\\ min(dp(n - coin) + 1) & n > 0 \\end{cases} ")])])],-1),g={class:"katex-html","aria-hidden":"true"},y=n('<span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span>',1),f={class:"base"},b=s("span",{class:"strut",style:{height:"4.32em","vertical-align":"-1.91em"}},null,-1),w={class:"minner"},v={class:"mopen"},_={class:"delimsizing mult"},x={class:"vlist-t vlist-t2"},j={class:"vlist-r"},z={class:"vlist",style:{height:"2.35em"}},E=s("span",{style:{top:"-2.2em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎩")])],-1),M={style:{top:"-2.192em"}},A=s("span",{class:"pstrut",style:{height:"3.15em"}},null,-1),N={style:{height:"0.316em",width:"0.8889em"}},T={xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.316em",style:{width:"0.8889em"},viewBox:"0 0 888.89 316",preserveAspectRatio:"xMinYMin"},B=s("path",{d:"M384 0 H504 V316 H384z M384 0 H504 V316 H384z"},null,-1),D=[B],H=s("span",{style:{top:"-3.15em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎨")])],-1),P={style:{top:"-4.292em"}},R=s("span",{class:"pstrut",style:{height:"3.15em"}},null,-1),V={style:{height:"0.316em",width:"0.8889em"}},S={xmlns:"http://www.w3.org/2000/svg",width:"0.8889em",height:"0.316em",style:{width:"0.8889em"},viewBox:"0 0 888.89 316",preserveAspectRatio:"xMinYMin"},C=s("path",{d:"M384 0 H504 V316 H384z M384 0 H504 V316 H384z"},null,-1),O=[C],F=s("span",{style:{top:"-4.6em"}},[s("span",{class:"pstrut",style:{height:"3.15em"}}),s("span",{class:"delimsizinginner delim-size4"},[s("span",null,"⎧")])],-1),G=s("span",{class:"vlist-s"},"​",-1),I=s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.85em"}},[s("span")])],-1),X=n('<span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">in</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span>',2),L=n(`<p>画出递归树：</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5w0nzsj75j20zk0k0acl.jpg" style="zoom:40%;"><p>很明显存在重叠子问题，下面用备忘录对递归树进行剪枝。</p><h3 id="带备忘录的递归-1" tabindex="-1"><a class="header-anchor" href="#带备忘录的递归-1"><span>带备忘录的递归</span></a></h3><p>和斐波那契那里一样，用一个备忘录存储计算过的值。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 查备忘录</span>
    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// for(...) {}</span>
  memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token operator">===</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="dp-table-递推-1" tabindex="-1"><a class="header-anchor" href="#dp-table-递推-1"><span>dp table 递推</span></a></h3><p>自底向上递推：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// base case</span>
  <span class="token comment">// 外层循环遍历所有状态</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 内层循环求所有选择的最小值</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 子问题无解</span>
        <span class="token keyword">continue</span>
      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!==</span> amount <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token operator">?</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
  	<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5w5rvxiqhj20zk0k0tb8.jpg" style="zoom:35%;"><p>dp 数组初始化为 <code>amount + 1</code> ，相当于取一个无穷大值 ( 全取 1 元硬币也只有 amount 枚 ) ，便于后续对比取最小值。不初始化为 <code>Number.MAX_SAFE_INTEGER</code> 是因为 <code>dp[i - coin] + 1 </code> 会导致整型溢出。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>动态规划代码框架有两种：</p><ul><li><p>自顶向下递归的动态规划</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token parameter">状态<span class="token number">1</span><span class="token punctuation">,</span> 状态<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 所有可能的选择
  	<span class="token comment">// 状态因做了选择而改变</span>
  	result <span class="token operator">=</span> <span class="token function">求最值</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>状态<span class="token number">1</span><span class="token punctuation">,</span> 状态<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>自底向上迭代的动态规划</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 初始化 base case</span>
dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">=</span> base <span class="token keyword">case</span>
<span class="token comment">// 进行状态转移</span>
 <span class="token keyword">for</span> 状态<span class="token number">1</span> <span class="token keyword">in</span> 状态<span class="token number">1</span>的所有取值
   <span class="token keyword">for</span> 状态<span class="token number">2</span> <span class="token keyword">in</span> 状态<span class="token number">2</span>的所有取值
     <span class="token keyword">for</span> <span class="token operator">...</span>
       dp<span class="token punctuation">[</span>状态<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>状态<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">求最值</span><span class="token punctuation">(</span>选择<span class="token number">1</span>，选择<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre></div></li></ul><p>这两种做法本质上是一样的，只是自顶向下和自底向上的不同而已。自顶向下用的是 dp 函数 ( 想象一棵树 )，自底向上用的是 dp table ( 想象一个数组 )。</p><p>思考状态转移方程的过程：</p><ol><li>状态是什么</li><li>确定 dp 数组或函数的定义</li><li>下一步选择什么状态</li><li>base case 是什么</li></ol>`,17);function Z(Y,q){return a(),p("div",null,[l,c,i,r,u,s("p",m,[s("span",k,[s("span",d,[h,s("span",g,[y,s("span",f,[b,s("span",w,[s("span",v,[s("span",_,[s("span",x,[s("span",j,[s("span",z,[E,s("span",M,[A,s("span",N,[(a(),p("svg",T,D))])]),H,s("span",P,[R,s("span",V,[(a(),p("svg",S,O))])]),F]),G]),I])])]),X])])])])])]),L])}const Q=e(o,[["render",Z],["__file","6.动态规划.html.vue"]]),U=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/6.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"动态规划 ( Dynamic Programming )","lang":"zh-CN","frontmatter":{"description":"动态规划 ( Dynamic Programming ) 动态规划问题的一般形式是求最值。解决动态规划问题的核心是穷举，穷举所有可行解，然后在其中找出最值。 动态规划三要素：最优子结构、状态转移方程、重叠子问题。 最优子结构：子问题的最值能否推出原问题的最值，这是动态规划的前提 状态转移方程：只有列出正确的状态转移方程，才能正确地穷举，这是核心步骤 重...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/6.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"动态规划 ( Dynamic Programming )"}],["meta",{"property":"og:description","content":"动态规划 ( Dynamic Programming ) 动态规划问题的一般形式是求最值。解决动态规划问题的核心是穷举，穷举所有可行解，然后在其中找出最值。 动态规划三要素：最优子结构、状态转移方程、重叠子问题。 最优子结构：子问题的最值能否推出原问题的最值，这是动态规划的前提 状态转移方程：只有列出正确的状态转移方程，才能正确地穷举，这是核心步骤 重..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划 ( Dynamic Programming )\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"斐波那契数列 ( 509 )","slug":"斐波那契数列-509","link":"#斐波那契数列-509","children":[{"level":3,"title":"暴力递归","slug":"暴力递归","link":"#暴力递归","children":[]},{"level":3,"title":"带备忘录的递归","slug":"带备忘录的递归","link":"#带备忘录的递归","children":[]},{"level":3,"title":"dp table 递推","slug":"dp-table-递推","link":"#dp-table-递推","children":[]}]},{"level":2,"title":"凑零钱问题 ( 322 )","slug":"凑零钱问题-322","link":"#凑零钱问题-322","children":[{"level":3,"title":"暴力递归","slug":"暴力递归-1","link":"#暴力递归-1","children":[]},{"level":3,"title":"带备忘录的递归","slug":"带备忘录的递归-1","link":"#带备忘录的递归-1","children":[]},{"level":3,"title":"dp table 递推","slug":"dp-table-递推-1","link":"#dp-table-递推-1","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":7.28,"words":2184},"filePathRelative":"编程/leetcode/6.动态规划.md","localizedDate":"2024年4月12日","autoDesc":true}');export{Q as comp,U as data};
