import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as t,c as o,e,b as n}from"./app-BzW9chhs.js";const c={},l=n(`<h1 id="二叉树构造" tabindex="-1"><a class="header-anchor" href="#二叉树构造"><span>二叉树构造</span></a></h1><p>二叉树的构造问题一般使用分解问题的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。</p><h2 id="构造最大二叉树-654" tabindex="-1"><a class="header-anchor" href="#构造最大二叉树-654"><span>构造最大二叉树 ( 654 )</span></a></h2><p>给定不含重复元素的数组，构造一颗最大二叉树。最大二叉树的根是数组的最大元素，最大值的左右部分分别构成左右子树。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lo <span class="token operator">&gt;</span> hi<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token comment">// base case</span>

  <span class="token comment">// 找到最大值的索引</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">getMaxIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>

  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整体思路很简单，先找到最大值索引 p，<code>nums[p]</code> 构成根节点，p 左边递归构造左子树，右边递归构造右子树。</p><h2 id="前中序构造-105" tabindex="-1"><a class="header-anchor" href="#前中序构造-105"><span>前中序构造 ( 105 )</span></a></h2><p>根据一棵树的前序遍历和中序遍历构建二叉树。比如：</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
  3
 / \\
9  20
  /  \\
 15   7
</code></pre></div><ul><li>前序遍历第一个节点是根节点</li><li>根节点将中序遍历数组分成左右子树</li></ul><p>所以，整体思路就是在中序遍历中找到根节点，然后递归调用根节点的左边和右边。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5tjqx3rgrj20gq05odfz.jpg" style="zoom:80%;"><p>代码大概如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> preS<span class="token punctuation">,</span> preE<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> inE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 根节点值</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token comment">/* 在 inorder 中找到根节点的位置 */</span>

  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre></div><p>其中主要问题在于递归调用时，preorder 和 inorder 的索引范围。</p><p>inorder 的索引范围也比较容易看出来。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
  preorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span>
  inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
  preorder<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span>
  inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inE<span class="token punctuation">)</span>
</code></pre></div><p>preorder 可以根据左子树的长度计算。设左子树的节点数为 <code>leftSize</code>，则 <code>preorder</code> 的索引情况是这样的：</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5tjqxxg16j20gq06et8x.jpg" style="zoom:80%;"><p>根据上图不难写出 preorder 的索引范围。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> leftSize <span class="token operator">=</span> index <span class="token operator">-</span> inS

root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
  preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>
  inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
  preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preE<span class="token punctuation">,</span>
  inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inE<span class="token punctuation">)</span>
</code></pre></div><p>在 inorder 中寻找 rootVal 时，为了防止多次循环，不妨用一个 hashMap 将 inorder 中的值和索引映射起来，方便查找。</p><p>再加上一些基础判断，最终代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> val2Idx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 存储 inorder 值与索引的映射</span>

<span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> preS<span class="token punctuation">,</span> preE<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> inE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>preS <span class="token operator">&gt;</span> preE<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token punctuation">}</span> <span class="token comment">// base case</span>

  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// preorder 根节点</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> val2Idx<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span> <span class="token comment">// inorder 根节点</span>

  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
  <span class="token keyword">const</span> leftSize <span class="token operator">=</span> index <span class="token operator">-</span> inS <span class="token comment">// 左子树节点数</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>
                    inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preE<span class="token punctuation">,</span>
                     inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inE<span class="token punctuation">)</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    val2Idc<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>
    preorder<span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然代码看起来有点多，主要是 preorder 和 inorder 的索引参数，画图就清楚了。</p><h2 id="后中序构造-106" tabindex="-1"><a class="header-anchor" href="#后中序构造-106"><span>后中序构造 ( 106 )</span></a></h2><p>后中序列构造与前中序列构造是非常类似的。都是先找根节点，然后在 inorder 和另外一个序列中找出左右子树边界，然后递归构造。</p><p>区别在于：</p><ul><li>前序遍历第一个元素是根节点，后序遍历则是最后一个元素</li><li>preorder 或 postorder 的索引范围不同</li></ul><p>postorder 也是通过 leftSize 判断范围的，具体如下图。</p><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5tkv48qmwj20h506bjrm.jpg" style="zoom:80%;"><p>核心部分代码如下：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> rootVal <span class="token operator">=</span> postorder<span class="token punctuation">[</span>postE<span class="token punctuation">]</span>
<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
<span class="token keyword">const</span> leftSize <span class="token operator">=</span> index <span class="token operator">-</span> inS

root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span>
                  postorder<span class="token punctuation">,</span> postS<span class="token punctuation">,</span> posS <span class="token operator">+</span> leftSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inE
                  postorder<span class="token punctuation">,</span> postS <span class="token operator">+</span> leftSize<span class="token punctuation">,</span> posE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="前后序构造-889" tabindex="-1"><a class="header-anchor" href="#前后序构造-889"><span>前后序构造 ( 889 )</span></a></h2><p>通过前中序、后中序遍历结果可以确定唯一二叉树，但是前后序遍历则无法确定。</p><p>比如以下前后序列可以构造成两种树，我们构造任意一种即可。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>preorder = [1,2,3]
postorder = [3,2,1]
</code></pre></div>`,37),r=n(`<p>前后序列构造二叉树，逻辑上和前两种差别不大，也是通过控制左右子树的索引来构建的。</p><ol><li>首先确定根节点，前序的首元素或后序的末元素都是根节点</li><li>前序列的第二个元素作为左子树的根节点</li><li>在后序列中寻找左子树根节点的值，从而确定左子树的索引边界，进而确定右子树的边界，然后递归构造左右子树</li></ol><img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5tmur2alaj20ke06r3yt.jpg" style="zoom:80%;"><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> preS<span class="token punctuation">,</span> preE<span class="token punctuation">,</span> post<span class="token punctuation">,</span> postS<span class="token punctuation">,</span> postE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>preS <span class="token operator">&gt;</span> preE<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>preS <span class="token operator">===</span> preE<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>preS<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> pre<span class="token punctuation">[</span>preS<span class="token punctuation">]</span>
  <span class="token keyword">const</span> lRootVal <span class="token operator">=</span> pre<span class="token punctuation">[</span>preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 左子树根节点</span>

  <span class="token keyword">const</span> index <span class="token operator">=</span> val2Idx<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lRootVal<span class="token punctuation">)</span>
  <span class="token keyword">const</span> leftSize <span class="token operator">=</span> index <span class="token operator">-</span> postS <span class="token operator">+</span> <span class="token number">1</span>

  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>
                    post<span class="token punctuation">,</span> postS<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> pre <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preE<span class="token punctuation">,</span>
                     post<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> postE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre></div><p>前后序遍历则无法确定唯一二叉树，我们选择其中一种构造。这体现在代码的这一行：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> lRootVal <span class="token operator">=</span> pre<span class="token punctuation">[</span>preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 左子树根节点</span>
</code></pre></div><p>这里我们假设了前序遍历的第二个元素是左子树根节点。实际上左子树有可能是空指针，第二个元素就应该是右子树根节点。</p><p>正是因为如此，根据前后序遍历构造二叉树才会有不同结果。</p><h2 id="序列化与反序列化" tabindex="-1"><a class="header-anchor" href="#序列化与反序列化"><span>序列化与反序列化</span></a></h2><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>如果序列化结果中不包含空指针信息，需要至少两种序列化结果才能确定一棵二叉树</li><li>如果不包含空指针信息，但提供两种序列化结果 <ul><li>前序 + 中序，可以确定二叉树</li><li>后序 + 中序，可以确定二叉树</li><li>前序 + 后序，不能确定二叉树</li></ul></li><li>如果包含空指针信息，且只提供一种序列化结果 <ul><li>前序，可以确定二叉树</li><li>后序，可以确定二叉树</li><li>中序，不能确定二叉树</li></ul></li></ul>`,11);function u(i,k){const s=p("Mermaid");return t(),o("div",null,[l,e(s,{id:"mermaid-107",code:"eJxFjUEKgzAURNfmFB+6iTBCY2wLCl2U3qC9gFpTxZCKWjSevmqk7v5/85h5t2lT0vPGvJRz4fsUBFfKOA+3M+dc+v6crp8RnJuv1gvJHAn/hHmjQ3KXxr3UrqXMs06KdsmRyS0xolynXXcvFA1l1RekKq3jg1IK1PXtpy5iOkgpk9nUlakfvdUFHSEQQiLCCWdcNjMYqldfxqIZF3vtpRQZcoywmGAETAgjYSI3lrAf4EpGOg=="}),r])}const g=a(c,[["render",u],["__file","3.1.二叉树构造.html.vue"]]),h=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/3.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0.html","title":"二叉树构造","lang":"zh-CN","frontmatter":{"description":"二叉树构造 二叉树的构造问题一般使用分解问题的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。 构造最大二叉树 ( 654 ) 给定不含重复元素的数组，构造一颗最大二叉树。最大二叉树的根是数组的最大元素，最大值的左右部分分别构成左右子树。 整体思路很简单，先找到最大值索引 p，nums[p] 构成根节点，p 左边递归构造左子树，右边递归构...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/3.1.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"二叉树构造"}],["meta",{"property":"og:description","content":"二叉树构造 二叉树的构造问题一般使用分解问题的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。 构造最大二叉树 ( 654 ) 给定不含重复元素的数组，构造一颗最大二叉树。最大二叉树的根是数组的最大元素，最大值的左右部分分别构成左右子树。 整体思路很简单，先找到最大值索引 p，nums[p] 构成根节点，p 左边递归构造左子树，右边递归构..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二叉树构造\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"构造最大二叉树 ( 654 )","slug":"构造最大二叉树-654","link":"#构造最大二叉树-654","children":[]},{"level":2,"title":"前中序构造 ( 105 )","slug":"前中序构造-105","link":"#前中序构造-105","children":[]},{"level":2,"title":"后中序构造 ( 106 )","slug":"后中序构造-106","link":"#后中序构造-106","children":[]},{"level":2,"title":"前后序构造 ( 889 )","slug":"前后序构造-889","link":"#前后序构造-889","children":[]},{"level":2,"title":"序列化与反序列化","slug":"序列化与反序列化","link":"#序列化与反序列化","children":[{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":4.99,"words":1496},"filePathRelative":"编程/leetcode/3.1.二叉树构造.md","localizedDate":"2024年4月12日","autoDesc":true}');export{g as comp,h as data};
