import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,b as n}from"./app-BzW9chhs.js";const t={},i=n('<h1 id="并行编程" tabindex="-1"><a class="header-anchor" href="#并行编程"><span>并行编程</span></a></h1><p>并行计算就是用非常多的线程合作解决一个问题。</p><h2 id="并行编程模型" tabindex="-1"><a class="header-anchor" href="#并行编程模型"><span>并行编程模型</span></a></h2><h3 id="共享存储模型" tabindex="-1"><a class="header-anchor" href="#共享存储模型"><span>共享存储模型</span></a></h3><h3 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型"><span>线程模型</span></a></h3><h3 id="消息传递模型" tabindex="-1"><a class="header-anchor" href="#消息传递模型"><span>消息传递模型</span></a></h3><h3 id="数据并行模型" tabindex="-1"><a class="header-anchor" href="#数据并行模型"><span>数据并行模型</span></a></h3><h3 id="具体实例" tabindex="-1"><a class="header-anchor" href="#具体实例"><span>具体实例</span></a></h3><ul><li>openMP</li><li>MPI</li><li>SPMD</li><li>MPMD</li></ul><h2 id="并行程序设计" tabindex="-1"><a class="header-anchor" href="#并行程序设计"><span>并行程序设计</span></a></h2><h3 id="自动和手动并行" tabindex="-1"><a class="header-anchor" href="#自动和手动并行"><span>自动和手动并行</span></a></h3><h3 id="理解问题和程序" tabindex="-1"><a class="header-anchor" href="#理解问题和程序"><span>理解问题和程序</span></a></h3><h3 id="分块分割" tabindex="-1"><a class="header-anchor" href="#分块分割"><span>分块分割</span></a></h3><h3 id="通信" tabindex="-1"><a class="header-anchor" href="#通信"><span>通信</span></a></h3><h3 id="同步" tabindex="-1"><a class="header-anchor" href="#同步"><span>同步</span></a></h3><h3 id="数据依赖" tabindex="-1"><a class="header-anchor" href="#数据依赖"><span>数据依赖</span></a></h3><h3 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡"><span>负载均衡</span></a></h3><h3 id="粒度" tabindex="-1"><a class="header-anchor" href="#粒度"><span>粒度</span></a></h3><h3 id="成本" tabindex="-1"><a class="header-anchor" href="#成本"><span>成本</span></a></h3><h3 id="性能分析和优化" tabindex="-1"><a class="header-anchor" href="#性能分析和优化"><span>性能分析和优化</span></a></h3><h2 id="通讯模式" tabindex="-1"><a class="header-anchor" href="#通讯模式"><span>通讯模式</span></a></h2><p>communication patterns</p><p>并行计算的输入输出之间数据的关系。</p><ul><li>映射 map: 一对一</li><li>聚合 gather： 多对一</li><li>分散 scatter： 一（少）对多</li><li>模板 stencil：serveral to one, 以特定模式读取相邻的值，比如一个像素的上下左右 4 个像素。</li><li>转置 transpose：一对一比如矩阵转置。</li><li>压缩 / 归约 reduce：多对一 all to one</li><li>重排 Scan / sort, all to all</li></ul>',24),s=[i];function r(h,c){return a(),l("div",null,s)}const p=e(t,[["render",r],["__file","2.并行编程.html.vue"]]),m=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/2.%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B.html","title":"并行编程","lang":"zh-CN","frontmatter":{"description":"并行编程 并行计算就是用非常多的线程合作解决一个问题。 并行编程模型 共享存储模型 线程模型 消息传递模型 数据并行模型 具体实例 openMP MPI SPMD MPMD 并行程序设计 自动和手动并行 理解问题和程序 分块分割 通信 同步 数据依赖 负载均衡 粒度 成本 性能分析和优化 通讯模式 communication patterns 并行计算...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/2.%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"并行编程"}],["meta",{"property":"og:description","content":"并行编程 并行计算就是用非常多的线程合作解决一个问题。 并行编程模型 共享存储模型 线程模型 消息传递模型 数据并行模型 具体实例 openMP MPI SPMD MPMD 并行程序设计 自动和手动并行 理解问题和程序 分块分割 通信 同步 数据依赖 负载均衡 粒度 成本 性能分析和优化 通讯模式 communication patterns 并行计算..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并行编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"并行编程模型","slug":"并行编程模型","link":"#并行编程模型","children":[{"level":3,"title":"共享存储模型","slug":"共享存储模型","link":"#共享存储模型","children":[]},{"level":3,"title":"线程模型","slug":"线程模型","link":"#线程模型","children":[]},{"level":3,"title":"消息传递模型","slug":"消息传递模型","link":"#消息传递模型","children":[]},{"level":3,"title":"数据并行模型","slug":"数据并行模型","link":"#数据并行模型","children":[]},{"level":3,"title":"具体实例","slug":"具体实例","link":"#具体实例","children":[]}]},{"level":2,"title":"并行程序设计","slug":"并行程序设计","link":"#并行程序设计","children":[{"level":3,"title":"自动和手动并行","slug":"自动和手动并行","link":"#自动和手动并行","children":[]},{"level":3,"title":"理解问题和程序","slug":"理解问题和程序","link":"#理解问题和程序","children":[]},{"level":3,"title":"分块分割","slug":"分块分割","link":"#分块分割","children":[]},{"level":3,"title":"通信","slug":"通信","link":"#通信","children":[]},{"level":3,"title":"同步","slug":"同步","link":"#同步","children":[]},{"level":3,"title":"数据依赖","slug":"数据依赖","link":"#数据依赖","children":[]},{"level":3,"title":"负载均衡","slug":"负载均衡","link":"#负载均衡","children":[]},{"level":3,"title":"粒度","slug":"粒度","link":"#粒度","children":[]},{"level":3,"title":"成本","slug":"成本","link":"#成本","children":[]},{"level":3,"title":"性能分析和优化","slug":"性能分析和优化","link":"#性能分析和优化","children":[]}]},{"level":2,"title":"通讯模式","slug":"通讯模式","link":"#通讯模式","children":[]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":0.71,"words":213},"filePathRelative":"编程/并行计算/2.并行编程.md","localizedDate":"2024年4月12日","autoDesc":true}');export{p as comp,m as data};
