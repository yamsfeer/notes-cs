import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as e,a as n,d as s,e as c,b as l}from"./app-BzW9chhs.js";const u={},r=n("h1",{id:"概述",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#概述"},[n("span",null,"概述")])],-1),k={href:"https://labuladong.github.io/algo/",target:"_blank",rel:"noopener noreferrer"},i=l(`<p>leetcode 题目非常多，但多数都有一定的规律或套路，找到这个规律，解题就像套模板一样，这就是原文作者提到的框架思维，即<strong>解题套路</strong>。</p><h2 id="数据结构的存储和基本操作" tabindex="-1"><a class="header-anchor" href="#数据结构的存储和基本操作"><span>数据结构的存储和基本操作</span></a></h2><h3 id="存储" tabindex="-1"><a class="header-anchor" href="#存储"><span>存储</span></a></h3><p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。</strong></p><p>顺序存储的优缺点：</p><ul><li>优点：可以随机访问且访问速度快</li><li>缺点：需要连续的内存空间，且数据的插入删除需要移动元素</li></ul><p>链式存储：</p><ul><li>优点：不存在扩容的问题，增加或删除节点快</li><li>缺点：无法随机访问且查找节点时间长</li></ul><p>在这两种存储方式之上，可以发展出其他各类数据结构。比如队列和栈，树是典型的链式存储，它还可以衍生出堆、二叉树、二叉搜索树、AVL树、图等等。</p><p>总之，数据结构种类很多，你也可以发明自己的数据结构，但是<strong>本质都是数组或者链表</strong>，这是由计算机结构决定的。</p><h3 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h3><p><strong>对于任何数据结构，基本操作无非遍历 + 访问（增、删、查、改）。</strong></p><p><strong>数据结构的遍历方式也有两种：线性和非线性的。</strong></p><p>线性以<strong>循环</strong>为代表，非线性以<strong>递归</strong>为代表。</p><ul><li><p>数组：迭代</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>链表：迭代或递归</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> head
  <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>二叉树：典型的递归</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul><p>总结一下：</p><ul><li>基本存储方式：顺序、链式</li><li>基本操作：增删查改</li><li>遍历方式：迭代、递归</li></ul><h2 id="算法的本质" tabindex="-1"><a class="header-anchor" href="#算法的本质"><span>算法的本质</span></a></h2><p>首先，算法工程师的“算法”，和数据结构与算法中的“算法”是两回事。</p><p>数据结构算法的重点在于<strong>计算机思维</strong>，需要你站在计算机的视角，抽象、化简实际问题，然后用合理的数据结构解决问题。本文讲的都是数据结构与算法中的算法，也可以称为计算机算法。</p><p>算法的本质是什么？对于计算机算法来说，<strong>算法的本质就是穷举</strong>。</p><p>对于计算机算法来说，解决问题的办法就是将所有符合要求的项都列出来，这就是穷举。</p><p>穷举有两个关键点：无遗漏、无冗余。遗漏，会直接导致答案出错；冗余，会拖慢算法的运行速度。因此，针对一道算法题，可以从两个维度去思考：</p><ol><li><p><strong>如何穷举</strong>？</p><p>即无遗漏地穷举所有可能解。一般是递归类问题，最典型的就是动态规划系列问题。</p><p>动态规划系列问题的核心原理，就是先写出暴力穷举解法，即状态转移方程，加个备忘录就是自顶向下的递归解法，再改一改就是自底向上的递推迭代解法。</p><p><strong>状态转移方程就是动态规划的难点，找到状态转移方程就穷举了所有可能解。</strong></p></li><li><p><strong>如何聪明地穷举</strong>？</p><p>即避免所有冗余的计算，消耗尽可能少的资源求出答案。非递归算法通常可以归为这一类。</p><p>比如贪心算法就是在题目中发现一些规律（贪心选择性质），使得不用完整穷举所有解就可得出答案。</p><p>动态规划是列出穷举所有解，然后选出其中最符合的，而贪心算法不需要穷举，这就是聪明的穷举。</p></li></ol><h2 id="框架思维" tabindex="-1"><a class="header-anchor" href="#框架思维"><span>框架思维</span></a></h2><p>建议学完基本算法之后，先从<strong>二叉树</strong>问题开始刷，培养框架思维，然后再看回溯、动规、分治等。</p><p>二叉树非常重要，因为<strong>二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。</strong></p><p>二叉树的遍历有前中后序遍历三种。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">TreeNode root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 中序位置</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>前序遍历——根据前序遍历和中序遍历的结果还原一棵二叉树</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> preS<span class="token punctuation">,</span> preE<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> inE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前序位置，寻找左右子树的索引</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>preS <span class="token operator">&gt;</span> preE<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>

  <span class="token keyword">let</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preS<span class="token punctuation">]</span> <span class="token comment">// 前序遍历第一个节点就是根节点</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> val2Index<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span> <span class="token comment">// 在中序遍历中找到根节点，拆开左右子树</span>

  <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
  <span class="token keyword">let</span> leftSize <span class="token operator">=</span> p <span class="token operator">-</span> inS <span class="token comment">// 左子树节点数</span>

  <span class="token comment">// 递归构造左右子树</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
    preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>
    inorder<span class="token punctuation">,</span> inS<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>
    preorder<span class="token punctuation">,</span> preS <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preE<span class="token punctuation">,</span>
    inorder<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inE
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre></div><p>从整体来看，代码是前序遍历结构。前序位置的代码是想求出所有子树的下标范围。</p></li><li><p>中序遍历——寻找二叉搜索树中的第 k 小的元素</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// BST 的中序遍历是有序的</span>
<span class="token keyword">let</span> rank <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> res <span class="token operator">=</span> root<span class="token punctuation">.</span>val

<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
  <span class="token comment">/* 中序位置 */</span>
  rank<span class="token operator">++</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>rank <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> res <span class="token operator">=</span> root<span class="token punctuation">.</span>val
  <span class="token punctuation">}</span>
  <span class="token comment">/* --- */</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>后序遍历——求二叉树中最大路径和</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> res <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MIN_SAFE_VALUE</span>
<span class="token keyword">function</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>

  <span class="token keyword">let</span> left <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// 后序位置</span>
  res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left <span class="token operator">+</span> right <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val
<span class="token punctuation">}</span>
</code></pre></div></li></ul><p><strong>事实上，只要是涉及递归的问题，都是树的问题</strong>。</p><p>下面再来看几个例子，说明为什么树那么重要。</p><h3 id="动态规划、回溯与树" tabindex="-1"><a class="header-anchor" href="#动态规划、回溯与树"><span>动态规划、回溯与树</span></a></h3><p>在动态规划的凑零钱问题中，解的空间是一棵树。</p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5915gr6sxj20zk0k0acl.jpg" style="zoom:40%;"><p>暴力解法就是遍历这棵 n 叉树。</p><p>动态规划算法很好的避免了重复计算图中颜色相同的节点及其子树，这就是聪明的穷举。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// base case</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>

  <span class="token keyword">let</span> res <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_VALUE</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">let</span> subProblem <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span>
    <span class="token comment">// 子问题无解则跳过</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subProblem <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>
    <span class="token comment">// 在子问题中选择最优解，然后加一</span>
    res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> subProblem <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res <span class="token operator">==</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_VALUE</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>提取核心代码，就是对 n 叉树的遍历。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 核心是 N 叉树的遍历问题</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">-</span> coin<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。</p><p>回溯算法更直接，<strong>回溯算法就是 n 叉树的前后序遍历问题，没有例外</strong>。</p><p>比如全排列问题的解就是遍历下面这棵树：</p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h5915n2f5sj20zk0k040a.jpg" style="zoom:40%;"><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> track</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span>
    track<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// 进入下一层决策树</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> track<span class="token punctuation">)</span>
    track<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>抽取核心代码：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 核心同样是 N 叉树遍历框架</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 进入下一层决策树</span>
  <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> track<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div>`,47);function d(m,g){const a=p("ExternalLinkIcon");return o(),e("div",null,[r,n("p",null,[s("这是我在阅读 "),n("a",k,[s("LABULADONG 的算法网站"),c(a)]),s(" 中的文章后做的笔记。")]),i])}const y=t(u,[["render",d],["__file","0.概述.html.vue"]]),v=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B/leetcode/0.%E6%A6%82%E8%BF%B0.html","title":"概述","lang":"zh-CN","frontmatter":{"description":"概述 这是我在阅读 LABULADONG 的算法网站 中的文章后做的笔记。 leetcode 题目非常多，但多数都有一定的规律或套路，找到这个规律，解题就像套模板一样，这就是原文作者提到的框架思维，即解题套路。 数据结构的存储和基本操作 存储 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。 顺序存储的优缺点： 优点：可以随机访问且访问...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E7%BC%96%E7%A8%8B/leetcode/0.%E6%A6%82%E8%BF%B0.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"概述 这是我在阅读 LABULADONG 的算法网站 中的文章后做的笔记。 leetcode 题目非常多，但多数都有一定的规律或套路，找到这个规律，解题就像套模板一样，这就是原文作者提到的框架思维，即解题套路。 数据结构的存储和基本操作 存储 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。 顺序存储的优缺点： 优点：可以随机访问且访问..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"数据结构的存储和基本操作","slug":"数据结构的存储和基本操作","link":"#数据结构的存储和基本操作","children":[{"level":3,"title":"存储","slug":"存储","link":"#存储","children":[]},{"level":3,"title":"遍历","slug":"遍历","link":"#遍历","children":[]}]},{"level":2,"title":"算法的本质","slug":"算法的本质","link":"#算法的本质","children":[]},{"level":2,"title":"框架思维","slug":"框架思维","link":"#框架思维","children":[{"level":3,"title":"动态规划、回溯与树","slug":"动态规划、回溯与树","link":"#动态规划、回溯与树","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":5.96,"words":1789},"filePathRelative":"编程/leetcode/0.概述.md","localizedDate":"2024年4月12日","autoDesc":true}');export{y as comp,v as data};
