import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as e,c as o,e as s,b as n}from"./app-BzW9chhs.js";const c={},l=n(`<h1 id="语法制导翻译" tabindex="-1"><a class="header-anchor" href="#语法制导翻译"><span>语法制导翻译</span></a></h1><p>编译器在语法分析的过程中，除了判断语法是否合法外，还需要完成类型检查、目标代码、中间代码生成等工作。</p><p>这些工作称为语法制导翻译，语法制导翻译的产物通常是<strong>抽象语法树（AST）</strong>。</p><h2 id="lr分析的语法制导翻译" tabindex="-1"><a class="header-anchor" href="#lr分析的语法制导翻译"><span>LR分析的语法制导翻译</span></a></h2><p>语法制导翻译的基本思想：</p><p>给每条产生式规则附加一个语义动作，在产生式归约时执行语义动作。语义动作是一个代码片段，通常是抽象语法树的构造函数。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>1: N -&gt; t_1     action_1(语义动作)
2:    | t_2     action_2
...             ...
n:    | t_n     action_n
</code></pre></div><p>在LR分析中：</p><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">[</span>state<span class="token punctuation">,</span> terminal<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39;ri&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 按第i条产生式归约</span>
  <span class="token function">action_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行相应的语义动作</span>
  <span class="token function">pop</span><span class="token punctuation">(</span>t_i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  state s <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">push</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">goto</span><span class="token punctuation">[</span>s<span class="token punctuation">,</span> N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在分析栈中需要维护一个三元组：<code>&lt;symbol, value, state&gt;</code>，其中：</p><ul><li><code>symbol</code>：终结符或非终结符</li><li><code>value</code>：<code>symbol</code>所拥有的值</li><li><code>state</code>：当前的分析状态</li></ul><h2 id="抽象语法树" tabindex="-1"><a class="header-anchor" href="#抽象语法树"><span>抽象语法树</span></a></h2><h3 id="从分析树到抽象语法树" tabindex="-1"><a class="header-anchor" href="#从分析树到抽象语法树"><span>从分析树到抽象语法树</span></a></h3><p>针对<code>3 + 4 * 5</code>推导的分析树：</p>`,14),i=n("<p>分析树编码了句子的推导过程，但是包含很多不必要的信息，这些信息需要<strong>占用额外的存储空间</strong>且<strong>增加遍历时间</strong>。</p><p>比如：</p><ul><li><p>对于表达式而言，编译只需要知道运算符和运算数（优先级、结合性等已经在语法分析部分处理掉了）。</p></li><li><p>经过语法分析后，编译器不需要再关心赋值符号是<code>=</code>还是<code>:=</code>。</p></li></ul><p>抽象语法树会去掉这些不必要的信息，使得针对抽象语法树的算法运行更快且更节约内存。</p>",4),u=n(`<h4 id="具体语法和抽象语法" tabindex="-1"><a class="header-anchor" href="#具体语法和抽象语法"><span>具体语法和抽象语法</span></a></h4><ul><li><p>具体语法是语法分析器使用的语法</p><p>具体语法适合于语法分析，如各种分隔符、消除左递归、提取公因子等。</p></li><li><p>抽象语法是用来表达语法结构的内部表达形式</p><p>现代编译器一般都采用抽象语法作为前端（词法语法分析）和后端（代码生成）的接口。</p></li></ul><h3 id="抽象语法树的数据结构" tabindex="-1"><a class="header-anchor" href="#抽象语法树的数据结构"><span>抽象语法树的数据结构</span></a></h3><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">Kind</span> <span class="token punctuation">{</span> E_INT<span class="token punctuation">,</span> E_ADD<span class="token punctuation">,</span> E_TIMES <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Exp</span><span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token class-name">Kind</span> kind<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Exp_Int</span> <span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token class-name">Kind</span> kind<span class="token punctuation">;</span>
  <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Exp_Add</span> <span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token class-name">Kind</span> kind<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">Exp</span><span class="token operator">*</span> left<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">Exp</span><span class="token operator">*</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">Exp_Times</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="lr分析中生成抽象语法树" tabindex="-1"><a class="header-anchor" href="#lr分析中生成抽象语法树"><span>LR分析中生成抽象语法树</span></a></h3><p>在LR分析的<strong>语法动作</strong>中，加入生成语法树的代码片段（通常是语法树的构造函数）。</p><p>在<strong>产生式归约</strong>的时候，就会自动调用语法树节点的构造函数，从而自底向上（叶子到根）构造语法树。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>E -&gt; E + E  { $$ = new Exp_ADD($1, $3) }
   | E * E  { $$ = new Exp_Times($1, $3) }
   | n      { $$ = new Exp_Int($1) }
</code></pre></div><h3 id="抽象语法树保留源代码信息" tabindex="-1"><a class="header-anchor" href="#抽象语法树保留源代码信息"><span>抽象语法树保留源代码信息</span></a></h3><p><strong>抽象语法树是编译器前端和后端的接口，程序一旦被转换成抽象语法树，则源代码即被丢弃，后序阶段只处理抽象语法树。</strong></p><p>所以抽象语法树必须编码足够多的源代码信息，比如每个语法结构在源代码中的位置，包括文件、代码行号列号等，方便后序报错时提供。</p><p>因此，<strong>抽象语法树必须仔细设计</strong>。</p><p>下面给出一个在抽象语法树中保存代码位置的例子：</p><div class="language-c" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">position</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
  <span class="token keyword">int</span> line<span class="token punctuation">;</span>
  <span class="token keyword">int</span> column<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">Exp_Add</span> <span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token class-name">Kind</span> kind<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">struct</span> <span class="token class-name">position</span> from<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">position</span> to<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>`,14);function r(d,k){const a=p("Mermaid");return e(),o("div",null,[l,s(a,{id:"mermaid-52",code:"eJx1jNEKgkAQRZ/zKwZ62a0R0tEKhR6ivqB+QHQ3F4cU3aj+vl0QCqV5m3vPPbe+6Gq4HgOAvm2tEGcpIQwPUNaGq2j6u4CkDBae/caxEOt5SpMxTW3kdYkf+huzn9ppV//bmd77U8cDsLk3F/tmBRuMMEbCBFPc4g73MNi+bVT4NJWts6h75Y4vuRiGk9JQKV082II2zNlSa40jn8GSiPLgA4TlT0c="}),i,s(a,{id:"mermaid-74",code:"eJxNytEKwiAYhuHjdhU/7ETLQc46cdBBdAd1AzI1ZT851KjuPoXB9h1+7/OManbwuDYAMYRMyIFS6LoLjM6j5oQISptdTevbE7LfKlHYqbK6hWxq4edSAdC/pnv+oYEj46xnAlKOYTLdx+vsJJ+/Q1EjqpRuxoI2Vr0xg/WIsrXWssVLaIUQQ/MHUNM0AQ=="}),u])}const E=t(c,[["render",r],["__file","4. 语法制导翻译.html.vue"]]),g=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.%20%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91.html","title":"语法制导翻译","lang":"zh-CN","frontmatter":{"description":"语法制导翻译 编译器在语法分析的过程中，除了判断语法是否合法外，还需要完成类型检查、目标代码、中间代码生成等工作。 这些工作称为语法制导翻译，语法制导翻译的产物通常是抽象语法树（AST）。 LR分析的语法制导翻译 语法制导翻译的基本思想： 给每条产生式规则附加一个语义动作，在产生式归约时执行语义动作。语义动作是一个代码片段，通常是抽象语法树的构造函数。...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4.%20%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"语法制导翻译"}],["meta",{"property":"og:description","content":"语法制导翻译 编译器在语法分析的过程中，除了判断语法是否合法外，还需要完成类型检查、目标代码、中间代码生成等工作。 这些工作称为语法制导翻译，语法制导翻译的产物通常是抽象语法树（AST）。 LR分析的语法制导翻译 语法制导翻译的基本思想： 给每条产生式规则附加一个语义动作，在产生式归约时执行语义动作。语义动作是一个代码片段，通常是抽象语法树的构造函数。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"语法制导翻译\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"LR分析的语法制导翻译","slug":"lr分析的语法制导翻译","link":"#lr分析的语法制导翻译","children":[]},{"level":2,"title":"抽象语法树","slug":"抽象语法树","link":"#抽象语法树","children":[{"level":3,"title":"从分析树到抽象语法树","slug":"从分析树到抽象语法树","link":"#从分析树到抽象语法树","children":[]},{"level":3,"title":"抽象语法树的数据结构","slug":"抽象语法树的数据结构","link":"#抽象语法树的数据结构","children":[]},{"level":3,"title":"LR分析中生成抽象语法树","slug":"lr分析中生成抽象语法树","link":"#lr分析中生成抽象语法树","children":[]},{"level":3,"title":"抽象语法树保留源代码信息","slug":"抽象语法树保留源代码信息","link":"#抽象语法树保留源代码信息","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":3.1,"words":930},"filePathRelative":"计算机基础/编译原理/4. 语法制导翻译.md","localizedDate":"2024年4月12日","autoDesc":true}');export{E as comp,g as data};
