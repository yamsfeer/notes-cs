import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as i,c,e as n,b as s,a as t,d as a}from"./app-BzW9chhs.js";const d={},r=s(`<h1 id="分析树和二义性文法" tabindex="-1"><a class="header-anchor" href="#分析树和二义性文法"><span>分析树和二义性文法</span></a></h1><h2 id="分析树" tabindex="-1"><a class="header-anchor" href="#分析树"><span>分析树</span></a></h2><p>在《上下文无关文法及推导》中，我们给出了一个<code>主谓宾</code>的文法和它的一个推导：</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>S -&gt; N V N
N -&gt; s
   | t
   | g
   | w
V -&gt; e
   | d
</code></pre></div><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>S -&gt; N V N
  -&gt; N d N
  -&gt; t d N
  -&gt; t d g
</code></pre></div><p>我们可以将这个推导过程化成树状图的形式，这棵树就是<strong>分析树</strong>：</p>`,6),p=s('<p><strong>分析树就是用树状结构表示的推导过程</strong>。它和推导所用的顺序无关（最左推导、最右推导或其它）。</p><p>分析树特点：</p><ul><li>内部节点都是非终结符</li><li>叶子节点都是终结符</li><li>每一步推导代表从父节点生成它的直接子节点</li><li>分析树的含义取决于树的<strong>后序遍历</strong>的顺序（后面会提到）</li></ul><h3 id="算术表达式的例子" tabindex="-1"><a class="header-anchor" href="#算术表达式的例子"><span>算术表达式的例子</span></a></h3>',4),m=t("p",null,[a("给定一个文法"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"G")]),t("annotation",{encoding:"application/x-tex"},"G")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"G")])])]),a("，推导出句子"),t("code",null,"3 + 4 * 5"),a("。"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"G")]),t("annotation",{encoding:"application/x-tex"},"G")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"G")])])]),a("表示如下：")],-1),h=s(`<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>E -&gt; num
   | id
   | E + E
   | E * E
</code></pre></div><p>观察文法和句子，显然第一步不能推<code>num</code>或<code>id</code>，这样推导直接结束了。</p><p>第一步可以推<code>E + E</code>或<code>E * E</code>，下面来分析这两种做法。</p><h4 id="先加法后乘法" tabindex="-1"><a class="header-anchor" href="#先加法后乘法"><span>先加法后乘法</span></a></h4><p>推导过程如下（使用最左推导）：</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>E -&gt; E + E
  -&gt; 3 + E
  -&gt; 3 + E * E
  -&gt; 3 + 4 * e
  -&gt; 3 + 4 * 5
</code></pre></div>`,6),g=t("h4",{id:"先乘法后加法",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#先乘法后加法"},[t("span",null,"先乘法后加法")])],-1),u=t("p",null,"推导过程如下（使用最左推导）：",-1),x=t("div",{class:"language-text","data-ext":"text","data-title":"text"},[t("pre",{class:"language-text"},[t("code",null,`E -> E * E
  -> E + E * E
  -> 3 + E * E
  -> 3 + 4 * E
  -> 3 + 4 * 5
`)])],-1),E=s('<p>两种推导方法都能得到句子<code>3 + 4 * 5</code>，但是分析树的结构完全不同，因而。</p><p><strong>分析树的含义取决于树的后序遍历的顺序</strong>。</p><p>第一棵树的后序遍历计算结果为：3 + (4 * 5) = 23</p><p>第二棵树的后序遍历计算结果为：(3 + 4) * 5 = 35</p><p>出现这种情况原因是：<strong>文法存在二义性</strong>。</p><h2 id="二义性" tabindex="-1"><a class="header-anchor" href="#二义性"><span>二义性</span></a></h2>',6),_=t("p",null,[a("给定一个文法"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"G")]),t("annotation",{encoding:"application/x-tex"},"G")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"G")])])]),a("，如果存在句子"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"S")]),t("annotation",{encoding:"application/x-tex"},"S")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S")])])]),a("，它有两棵不同的分析树，那么称"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"G")]),t("annotation",{encoding:"application/x-tex"},"G")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"G")])])]),a("为"),t("strong",null,"二义性文法"),a("。")],-1),w=t("p",null,[a("从编译器角度，二义性文法的问题："),t("strong",null,"同一个程序有不同的含义，程序运行结果不是唯一的"),a("。")],-1),k=t("p",null,[a("解决方案："),t("strong",null,"文法的重写"),a("。")],-1),A=t("p",null,[a("不存在通用的方法"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"f")]),t("annotation",{encoding:"application/x-tex"},"f")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f")])])]),a("，使得任意二义性文法都能通过"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"f")]),t("annotation",{encoding:"application/x-tex"},"f")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f")])])]),a("改写为非二义性文法。需要具体观察当前文法进行改写。")],-1),M=t("h3",{id:"表达式文法的重写",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#表达式文法的重写"},[t("span",null,"表达式文法的重写")])],-1),f=t("p",null,[a("将上述"),t("code",null,"算术表达式"),a("例子的文法"),t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mi",null,"G")]),t("annotation",{encoding:"application/x-tex"},"G")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.6833em"}}),t("span",{class:"mord mathnormal"},"G")])])]),a("重写为：")],-1),v=t("div",{class:"language-text","data-ext":"text","data-title":"text"},[t("pre",{class:"language-text"},[t("code",null,`E -> E + T
   | T
T -> T * F
   | F
F -> num
   | id
`)])],-1),y=t("p",null,[a("对句子"),t("code",null,"3 + 4 * 5"),a("的推导过程为：")],-1),b=t("div",{class:"language-text","data-ext":"text","data-title":"text"},[t("pre",{class:"language-text"},[t("code",null,`E -> E + T
  -> T + T
  -> F + T
  -> 3 + T
  -> 3 + T * F
  -> 3 + F * F
  -> 3 + 4 * F
  -> 3 + 4 * 5
`)])],-1),F=t("p",null,[a("这棵分析树的后序遍历计算结果为"),t("code",null,"3 + (4 * 5) = 23"),a("，计算结果正确且分析树唯一。")],-1);function B(G,T){const e=o("Mermaid");return i(),c("div",null,[r,n(e,{id:"mermaid-14",code:"eJxlzz0LgzAQBuC5/oqDLgmc0OTaRaFD6dzF0l00McFQRQO2/75RA/2aXu54ON5rhrI3cD0lAEPXecYKziFNj1AZ62rB2OVrDgvPebKZ7XstGbt9MhlY/c/o5xoF1gQGULlyHM9Kw2SsV6Ctc9lWa40w+qFrVQZbIsqDdPbeFv7pFOxQoETCPR6iSidbe5OJ/jHL5ebyFK7dY8SUMeJIMcRaIU9eBI5SCQ=="}),p,m,h,n(e,{id:"mermaid-63",code:"eJx1jNEKgkAQRZ/zKwZ62a0R0tEKhR6ivqB+QHQ3F4cU3aj+vl0QCqV5m3vPPbe+6Gq4HgOAvm2tEGcpIQwPUNaGq2j6u4CkDBae/caxEOt5SpMxTW3kdYkf+huzn9ppV//bmd77U8cDsLk3F/tmBRuMMEbCBFPc4g73MNi+bVT4NJWts6h75Y4vuRiGk9JQKV082II2zNlSa40jn8GSiPLgA4TlT0c="}),g,u,x,n(e,{id:"mermaid-71",code:"eJyNj00OgjAQhddyiknYFB0SoeAPJC6MnkAvQKCVhkYI1Ki3dwATARc6u/nmfXmZS51UOZz3FkBdloaxo+OA6+4gzZXOvG6n23j62yDW54aACP/H9BlbjEyfTCK/TT7t5GQGZM7aRz6cGubfdGq3ctjVanUtTuapBSzRQx85BhjiCte4wS00pi4L4d5VZvLIqx4xGalOmuYgJGRCJjdtQCqtI1tKie98BDbnPLZeyftbgg=="}),E,_,w,k,A,M,f,v,y,b,n(e,{id:"mermaid-113",code:"eJxtjk0OgkAMhddwiiZsBi2Jw4A/kLgw6gXkAgQYIUyEwBj19hYxEYFlv9fvtdcmrnOIDiZAU1WasZNtg+PsIckLlfLPbBpd9KMuY8spFYxFHTWNXh20UA1FQ0DkPCKEROf3ZYPesS0mNhFC3qxNzy5mA/r3v6Q75NMqgCpu5UW/VAYr5OiiQA99XOMGt7hDTpBDq5uqzJxHkeo84PUzJC9RcdseMwlpJuO70iALpQJLSonf/QAsIURovgGMRGJ6"}),F])}const Q=l(d,[["render",B],["__file","3.2 分析树和二义性文法.html.vue"]]),L=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.2%20%E5%88%86%E6%9E%90%E6%A0%91%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95.html","title":"分析树和二义性文法","lang":"zh-CN","frontmatter":{"description":"分析树和二义性文法 分析树 在《上下文无关文法及推导》中，我们给出了一个主谓宾的文法和它的一个推导： 我们可以将这个推导过程化成树状图的形式，这棵树就是分析树： 分析树就是用树状结构表示的推导过程。它和推导所用的顺序无关（最左推导、最右推导或其它）。 分析树特点： 内部节点都是非终结符 叶子节点都是终结符 每一步推导代表从父节点生成它的直接子节点 分析...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.2%20%E5%88%86%E6%9E%90%E6%A0%91%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"分析树和二义性文法"}],["meta",{"property":"og:description","content":"分析树和二义性文法 分析树 在《上下文无关文法及推导》中，我们给出了一个主谓宾的文法和它的一个推导： 我们可以将这个推导过程化成树状图的形式，这棵树就是分析树： 分析树就是用树状结构表示的推导过程。它和推导所用的顺序无关（最左推导、最右推导或其它）。 分析树特点： 内部节点都是非终结符 叶子节点都是终结符 每一步推导代表从父节点生成它的直接子节点 分析..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T15:44:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T15:44:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分析树和二义性文法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T15:44:18.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"分析树","slug":"分析树","link":"#分析树","children":[{"level":3,"title":"算术表达式的例子","slug":"算术表达式的例子","link":"#算术表达式的例子","children":[]}]},{"level":2,"title":"二义性","slug":"二义性","link":"#二义性","children":[{"level":3,"title":"表达式文法的重写","slug":"表达式文法的重写","link":"#表达式文法的重写","children":[]}]}],"git":{"createdTime":1712936658000,"updatedTime":1712936658000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":2.89,"words":867},"filePathRelative":"计算机基础/编译原理/3.2 分析树和二义性文法.md","localizedDate":"2024年4月12日","autoDesc":true}');export{Q as comp,L as data};
