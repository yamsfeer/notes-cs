# 数的表示和计算

**计算机中存储和处理的都是0和1**。对于一台16位的机器中的某个数据

```c
1001 1010 1000 1110 // 9A 8E
```

它可能是一个指令、一个地址，也可能是一个数字。

我们平常使用的正负数、整数、小数等是怎么被存储表示和计算的？这是本文要讨论的内容。

## 数的表示

### 数据宽度

在计算机中，受硬件的制约，数据是有长度限制的，称之为**数据宽度**，超出最大宽度的数据会被**丢弃**。

计算机中常见的数据宽度：

* 比特(bit)：1位
* 字节(byte)：8位
* 字(word)：16位
* 双字(double word)：32位

由数据宽度可以得出对应的存储范围：

* 比特(bit)：`0 或 1`
* 字节(byte)：`0 ~ 0xFF`
* 字(word)：`0 ~ 0xFFFF`
* 双字(double word)：`0 ~ 0xFFFFFFFF`

### 无符号数和有符号数

有符号数和无符号数的区别在于：

* **有符号数的最高位是符号位，0表示正数，1表示负数**
* 无符号数没有符号位
* 正数的有符号数和无符号数表示相同

```c
short num = 0x1A00; // 0001 1010 0000 0000
printf("无符号数：%u\n", num); // 无符号数：6656
printf("有符号数：%d\n", num); // 有符号数：6656

short num = 0x9A00; // 1001 1010 0000 0000
printf("无符号数：%u\n", num); // 无符号数：4294941184
printf("有符号数：%d\n", num); // 有符号数：-26112
```

### 原码、反码、补码、移码

* 原码

  最高位为符号位，其余各位为数值本身（真值）的绝对值

* 反码

  * 正数：反码和原码相同
  * 负数：符号位为1，其余位对原码取反

* 补码

  * 正数：补码和原码相同
  * 负数：符号位为1，其余位对原码取反加1（符号位不变，反码加1）

* 移码：补码符号位取反得移码（用于浮点数，详见“定点数和浮点数”）

[2]<sub>真</sub> = [0000 0010]<sub>原</sub> = [0000 0010]<sub>反</sub> = [0000 0010]<sub>补</sub> 

[-7]<sub>真</sub> = [1000 0111]<sub>原</sub> = [1111 1000]<sub>反</sub> = [1111 1001]<sub>补</sub> 

总结一下：

* **正数的原码、反码、补码相同**
* 负数的原码**保持符号位不变**，其余位取反是反码，取反后加1是补码
* **计算机正负数都用补码存储表示**（原因见下文）

### 补码求原码

上文提到了`原码=>反码=>补码`和`原码=>补码`的转换方法。

**补码=>原码**的过程：

1. 如果符号位为0，表示是正数，原码补码相同

2. 如果符号位为1，表示是负数

   **符号位为1，其余各位取反后加1（负数补码的补码就是原码，类似负负得正）**

[1000]<sub>补</sub> => 负数，000取反得111，111是十进制的7，7 + 1 = 8 => [1000]<sub>补</sub>= [-8]<sub>真</sub>。

[1111]<sub>补</sub> => 负数，111取反得到000，000是十进制的0，0 + 1=1 => [1111]<sub>补</sub> = [-1]<sub>真</sub>。

### 为什么用补码表示数

对于人来说，在计算二进制时会根据符号位，判断正负数，然后对真值绝对值计算加减。

对于计算机来说，辨别符号位会让计算机的电路设计变得十分复杂。

于是人们想出了**将符号位也参与运算**的方法。

用原码、反码、补码三种方式计算`1 - 1 = 1 + (-1) = 0`

* 原码

  1 + (-1) = [0001]<sub>原</sub> + [1001]<sub>原</sub> = [1010]<sub>原</sub> = -2

  用原码表示，对于减法来说，结果显然不正确。

  所以计算机内部不使用原码表示一个数。

* 反码

  原码计算减法不正确，于是出现了反码：

  1 + (-1) = [0001]<sub>原</sub> + [1001]<sub>原</sub> = [0001]<sub>反</sub>+ [1110]<sub>反</sub> = [1111]<sub>反</sub> = [1000]<sub>原</sub> = -0

  用反码计算减法，得到的真值是正确的。

  但是出现了`-0 / +0`，使得`0`有[0000]<sub>原</sub>和[1000]<sub>原</sub>两种编码表示。

* 补码

  补码的出现，解决了反码的问题。

  1 + (-1) = [0001]<sub>原</sub> + [1001]<sub>原</sub> = [001]<sub>补</sub>+ [1111]<sub>补</sub>= [0000]<sub>补</sub>=[0000]<sub>原</sub> = 0

  补码不仅修复了`-0 / +0`以及`0`存在两个编码的问题，还可以用原本`-0`的编码来表示最低数，比如[1000 0000]<sub>补</sub>表示-128（注意-128没有原码和反码表示）。

  所以8位二进制，原码或反码表示范围为[-127, +127]，补码表示范围为[-128, 127]。

总结：

* 辨别符号位使电路设计复杂，于是符号位参与运算
* 在符号位参与运算的情况下，原码计算减法结果不正确，于是提出反码
* 使用反码会有`-0 / +0`的问题，于是提出补码，问题解决
* 最终，计算机使用补码表示和计算正负数（正数原码、补码相同）

## 定点数和浮点数

[什么是定点数？](https://zhuanlan.zhihu.com/p/338588296)

[什么是浮点数？](https://zhuanlan.zhihu.com/p/339949186)

## 位运算

位运算符有7种：与( & ) 、或( | )、非( ~ )、异或( ^ )、左移( << )、右移( >> ) 、无符号右移( >>> )， 非运算为一元操作符，其它都是二元操作符。 

下面的例子都是8位的位运算，32、64位的位运算同理。

* 与(`and, &`)

  **两个位都为1时，结果为1。**

  ```
               1011 0001
  and(&)       1101 1000
  ----------------------
               1001 0000
  ```

* 或(`or, |`)

  **两个位至少有一个为1时，结果为1。**

  ```
               1011 0001
  or(|)        1101 1000
  ----------------------
               1111 1001
  ```

* 非(`not, ~`)

  **按位取反，1变0，0变1。**

  ```
  not(~)       1101 1000
  ----------------------
               0010 0111
  ```

* 异或(`xor, ^`)

  **两个位不相同时为1。**

  ```
               1011 0001
  xor(^)       1101 1000
  ----------------------
               0110 1001
  ```

* 左移(`shl, <<`)

  **各二进制位左移若干位，高位丢弃，低位补0。**

  `a << b`表示a左移b位，相当于 $a * 2^b$。

  ```
               1101 1000
  shl(<<)              2
  ----------------------
               0110 0000
  ```

* 右移(`shr, >>`)

  **各二进制位右移若干位，低位丢弃，高位补符号位**。

  `a >> b`相当于$a / 2^b$，高位补原符号位（0或1）。

  ```
               1101 0101
  shr(>>)              2
  ----------------------
               1111 0101

* 无符号右移(`>>>`)

  **各二进制位右移若干位，低位丢弃，高位补0**。

  `a >>> b`相当于$a / 2^b$。

  ```
               1101 0101
  >>>                  2
  ----------------------
               0011 0101
  ```

## 四则运算

在计算机中，有`与门`、`或门`、`非门`等`门电路`，这些电路组合在一起实现了`加法器`、`减法器`等元器件。

因此可以说，**计算机只会做位运算**，四则运算是**在位运算的基础上**实现的。

### 加法

简单来说，用位运算来实现加法有两点：

* **异或运算是没有进位的加法**
* **与运算得到进位数**

位运算实现加法$a + b$的具体过程：

1. 异或运算，$c = a \ xor \ b$
2. 与运算判断是否有进位，$d = a \ \& \ b$，若$d \ne 0$，则有进位
3. 如果有进位，
   1. $d$左移一位
   2. $d$和$c$重复步骤1和步骤2，直到没有进位
4. 如果没有进位，$c$就是$a \ + \ b$的结果

下文将以`4(0000 0100) + 5(0000 0101)`介绍加法的实现原理：

1. $c = 4 xor 5$，$c$是$4 + 5$不考虑进位时的结果

   ```
             0000 0100(4)
   xor(^)    0000 0101(5)
   -------------------
             0000 0001(c)
   ```

2. $d = 4 \& 5$，与运算的作用是找出发生进位的位置。

   ```
             0000 0100(4)
   and(&)    0000 0101(5)
   -------------------
             0000 0100(d)
   ```

   如果$d = 0$，说明没有进位，那么 $c$ 就是$4+5$的结果。

   但是$d = 0100 \ne 0$，说明有进位，且进位就发生在第3位。

3. $e = c \ xor \ (d << 1)$

   进位发生在第三位，所以进位结果应该是1000。

   此时，$4 + 5 = c + (d << 1)$

   ```
             0000 0001(c)
   xor(^)    0000 1000(d << 1)
   -------------------
             0000 1001(e)
   ```

   **这一步仍要检查是否有进位。**

4. $c \& (d << 1)$

   ```
             0000 0001(c)
   and(&)    0000 1000(d << 1)
   -------------------
             0000 0000
   ```

   没有进位，$e$就是最终结果，即`0100 + 0101  = 1001`。

```flow
st=>start: 开始
cond=>condition: 有进位？
op1=>operation: 异或运算
op2=>operation: 与运算
op3=>operation: 左移一位
e=>end: 结束

st->op1->op2(right)->cond
cond(yes, right)->op3(right)->op1
cond(no)->e
```

### 减法、乘法、除法

减法、乘法、除法都可以转化为加法。比如：

* 减法：`10 - 5 = 10 + (-5)`
* 乘法：`10 * 5 = 10 + 10 + 10 + 10 + 10`
* 除法：`10 / 5 = 多少个5相加等于10？`

## 参考

[原码、反码、补码和移码详解](https://www.jianshu.com/p/abbdae4f3841)

[汇编语言视频课程](https://study.163.com/course/courseMain.htm?courseId=1003265009)

[什么是定点数？](https://zhuanlan.zhihu.com/p/338588296)

[什么是浮点数？](https://zhuanlan.zhihu.com/p/339949186)

