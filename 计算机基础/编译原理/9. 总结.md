# 总结

编译就是把一门计算机语言翻译成另一门计算机语言的过程，最终的输出结果通常是汇编语言或另一门高级语言。

编译是由多阶段构成的流水线过程，主要包括词法分析、语法分析、语义分析、代码生成、代码优化等流程，上一阶段的输出是下一阶段的输入。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gstbtj1gozj30m104j3yw.jpg)

## 词法分析

词法分析会把**字符流识别并划分为一个个有意义的词法单元，称为token**。

词法分析的原理是有限状态自动机。获得这个有限状态自动机（词法分析器）有两种方法：

* 手动编写
* 词法分析器生成器

常用的词法分析器生成器有[flex](https://zh.wikipedia.org/wiki/Flex%E8%A9%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)，它的原理在于通过一系列算法，将表示词法规则的正则表达式转换为有限状态自动机来作为词法分析器。

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gsvlz5ftrlj30m0028t8q.jpg)

## 语法分析

语法分析，或者说语法分析器的任务主要有两个：

* 语法检查
* 生成抽象语法树

语法检查：提供程序语言的语法规则，判断程序代码是否符合这个语法规则（语法规则是用上下文无关文法描述的）。

要判断代码是否符合语法规则，有两类算法：

- 自顶向下分析算法
  - 递归下降分析算法
  - LL 分析算法
- 自底向上分析算法
  - LR 分析算法

其中递归下降分析算法可用于手工编写语法分析器，LL和LR分析算法用于语法分析器生成器。

LL和LR分析算法都是表驱动的：

* LL算法通过NULLABLE集、FOLLOW集、FIRST_S集构建出LL分析表

  ![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gt1qlr4018j30e605wt8t.jpg)

* LR算法需要构造ACTION表和GOTO表

  ![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gtu6ak066uj60ec07it8x02.jpg)

语法分析器生成器的作用就是根据语法规则生成分析表。



**抽象语法树是编译器前端和后端的接口**，程序一旦被转换成抽象语法树，则源代码即被丢弃，后序阶段只处理抽象语法树。

以LR分析算法为例，生成抽象语法树就是在LR分析算法进行归约时，执行一个语义动作（通常是构造抽象语法树的节点），从叶子到根构建整棵树。

## 语义分析

语义分析也称为**类型检查**、**上下文相关分析**。

语义分析负责检查程序（**抽象语法树**）的**上下文相关属性**，**检查内容与具体的源语言相关**，通常包括：

* 变量先声明后使用
* 表达式都有合适的类型
* 函数调用和函数的定义一致
* ...

表达式类型检查、变量声明、语句处理等都需要用到符号表作查询。因此，**符号表的实现是语义检查的核心数据结构**。

**符号表是用来存储程序中变量相关信息**，包括

* 类型
* 作用域
* 访问控制信息
* ...

高效的实现符号表，主要考虑两点：时间复杂度和空间复杂度。常见的两种符号表数据结构：

* 使用哈希表等，查找时间复杂度为O(1)，占用空间大
* 使用红黑树等平衡树，查找时间复杂度为O(lg N)，节约空间

## 代码生成

经过语义检查后，需要进一步将抽象语法树转化。根据现实情况，可以直接将抽象语法树转化为目标机器的汇编代码，但在现代编译器中，通常会将抽象语法树转化为各种中间表示，方便进行代码优化。

常见的中间表示有：

* 树和有向无环图（*DAG, Directed Acyclic Graph*）

  这是一种高层表示，适用于程序源代码

* 三地址码（*3-address code*）

  低层表示，靠近目标机器

* 控制流图（*CFG, control-flow graph*）

  更精细的三地址码，是程序的图状表示。适合做程序分析、程序优化等。

* 静态单赋值形式（*SSA, static single assignment form*）

  更精细的控制流图，同时编码控制流信息和数据流信息。

* 连续传递风格（*CPS, Continuation-passing style*）

  更一般的SSA。

转化成这些中间表示的目的是代码优化。

换句话说，代码优化是在这些中间表示的基础上进行的，我们需要在这些中间表示上进行程序分析，根据分析结果做优化。

程序分析有：

* 控制流分析
* 数据流分析
  * 到达定义分析
  * 活性分析

其中控制流分析和数据流分析都基于控制流图，而控制流图是通过三地址码得到的。

## 代码优化

* 前期优化
  * 常量折叠
  * 代数化简
  * 不可达代码删除
* 中期优化
  * 常量传播
  * 拷贝传播
  * 死代码删除

## 编译器流水线图

![](https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gty3jsr771j61m40i2aeg02.jpg)

## 编译原理思维导图

![](http://assets.processon.com/chart_image/6127604e1efad446c34f17c9.png)
