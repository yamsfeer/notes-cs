# 自顶向下分析

语法分析的作用之一，相当于给定文法$G$和句子$S$，判断$G$能否推导出$S$。

为实现这个判断，我们可以：

* 从$G$的开始符号出发，每推导出一个句子，就和$S$做一次比较
* 如果相等，结束推导，$G$可以推导出$S$
* 如果不相等，继续推导直到相等或完成全部推导，$G$不能推导出$S$

该过程是从开始符号出发推出句子，因此称为**自顶向下分析**。

**自顶向下分析**对应**分析树自顶向下的构造顺序**。

## 自顶向下分析的例子

举个自顶向下分析的例子（依旧是`主谓宾`的例子）：

1. 给定文法$G$：

   ```
   S -> N V N
   N -> s
      | t
      | g
      | w
   V -> e
      | d
   ```

   推导句子$S$ = `g d w`。

2. 我们选择`最左推导`，一次可能的推导过程如下：

   ```
   S -> N V N 
     -> s V N 
     -> s e N
     -> s e t
   ```

   此次推导结果与句子不等，进行下一次推导。

3. 若干次尝试后，我们最终可以得到正确的推导过程

   ```
   S -> N V N
     -> g V N
     -> g d N 
     -> g d w
   ```

   结束推导，$G$可以推导出$S$。

很明显，我们不需要推导出整个句子后才与目标句子比较。

比如在第2步的推导中，当推导出第一个终结符`s`时，即可判断与目标句子的`g`不相等。

因此，我们做出如下改进：

* 每得到一个终结符，与所需要匹配的句子里面相应的字符进行比较
* 如果不相等，回溯，进行下一次推导

算法过程伪代码如下：

```c
tokens[]; // all tokens
i = 0;
stack = [S]; // S 是开始符号
while(stack not empty)
  if(stack[top] is a terminal t) //栈顶是终结符
    t == tokens[i++]
    	? pop()
    	: backtrack(); // 终结符与目标字符不等，回溯
  else if(stack[top] is a nonterminal T) //栈顶是非终结符
    pop();
		/* 选择哪个压栈会在LL分析算法里讲解
		   本节先将T的右边压栈 */
    push(the next right hand side of T);
```

## 算法的讨论

上述自顶向下分析过程改进后的效率仍不能使人满意。为了编译上千万行的内核等程序，编译器必须足够高效。

实际上，我们需要**线性时**间的算法。为此，需要**避免回溯**。

这里引出**递归下降分析算法**和**LL(1)分析算法**。
