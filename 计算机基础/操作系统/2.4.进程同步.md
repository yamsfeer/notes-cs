# 进程同步

## 信号量

进程需要信号量判断自身是否等待或唤醒。

信号量非常重要，必须保证信号量是正确的。因为进程随时可能被切走，错误的信号量会造成进程同步错误。

为了保证信号量正确，需要对信号量进行保护，具体来说就是加锁。

进程中修改信号量的代码称为临界区，必须保证同一时刻只有一个进程在一个信号量的临界区，即某一时刻只能有一个进程在修改信号量。

## 锁算法

之所以要保护信号量，是因为进程调度可能使得信号量不正确（A进程处理完信号量之前切到进程 B，B又修改了信号量）

因为，锁的作用是保持临界区的原子性。

### 面包店算法

在软件层面实现

### 开关中断

硬件实现

### 硬件原子指令

硬件实现

单个指令是不可能被打断的。

## 死锁

### 形成死锁的条件

* 互斥使用 ( Mutual exclusion )：资源的固有特性
* 不可抢占 ( No preemption )：资源只能自愿放弃
* 请求和保持 ( Hold and wait )：进程必须占有资源，再去申请
* 循环等待 ( Circular wait )：在资源分配图中存在环

### 处理方法

* 预防死锁：破坏死锁出现的条件，比如一次申请所有资源
* 避免死锁： 检查每个资源请求，如果会造成死锁则拒绝，银行家算法
* 死锁检测和恢复：出现死锁时，进程回滚，让出资源
* 死锁忽略：直接忽略

死锁出现概率较小，且其他方法代价较高，因此通常采用死锁忽略。

## 总结