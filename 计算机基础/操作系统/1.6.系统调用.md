# 系统调用

系统调用其实就是操作系统提供的函数调用。

任务管理相关系统调用：

| 系统调用       | 描述           |
| -------------- | -------------- |
| fork           | 创建进程       |
| execl          | 运行可执行程序 |
| pthread_create | 创建线程       |

文件系统相关系统调用：

| 系统调用       | 描述                 |
| -------------- | -------------------- |
| open           | 打开文件             |
| EACCES         | 返回值，表示没有权限 |
| mode_t st_mode | 文件头结构：文件属性 |

POSIX：Portable Operating Symstem Interface of Unix，可移植操作系统接口，IEEE 制定的系统调用接口。



为什么：隔离内核程序和用户程序，保护内核

如何实现：CPU 硬件区分内核态和用户态

怎么办：通过中断进入内核

## 内核态与用户态

内核态和用户态是由硬件设计实现的。内核态可以访问任何数据，用户态不能访问内核数据，这是对操作系统的保护。

内核态和用户态是 CPU 的两种状态，分别表示执行内核代码和用户代码。在内存中也有类似概念，内存中同时保存着操作系统，应用程序的指令和数据，可以把它们称为用户空间和内核空间，或者用户内存段和内内存核段。

具体实现措施：用户段的指令不能跳转到内核段，具体来说，就是检查 CPL 和 DPL 的大小，0 表示内核态，3 表示用户态，这些值都保存在 GDT 表中，在初始化时已设置好。

如何实现内核态和用户态？



CPU 判断当前段 （CS） 的层级 CPL 与目标段 （DS）的层级 DPL 的大小，层级越小越重要，内核态为 0，os 服务为 1,2，用户态为 3

内核态可以访问任何数据，用户态不能访问内核数据。

os 内存中，各段的 level 都存放在 GDT 表中。

## 中断进入内核

中断指令 int ( interrupt )，int 指令将 CS 中的 CPL 改成 0，即改为内核态。

中断是用户程序调用内核的**唯一方式**。

因此，用户进行 printf 之类的系统调用时，必然会被编译成包含 int 指令的代码。

```
用户调用 printf => C语言库函数 printf => C语言库函数 write => 系统调用 write
```

### int 0x80

int 0x80 会通过查 IDT 表寻找需要跳转执行的指令，执行完后再跳回来。

1. 用户调用 printf
2. printf 转换成包含 int 0x80 的代码，设置 CPL = 0，DPL = 3，这样才能允许进入内核态
3. （以下是内核态）
4. 中断处理 system_call
5. 查表 sys_call_table
6. `__NR_write = 4`
7. 调用 sys_write